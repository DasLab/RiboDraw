
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>draw_helix</title><meta name="generator" content="MATLAB 9.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-11-17"><meta name="DC.source" content="draw_helix.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="keyword">function</span> helix = draw_helix( helix )
<span class="comment">% helix = draw_helix( helix )</span>
<span class="comment">% (C) R. Das, Stanford University, 2017</span>

<span class="keyword">if</span> ischar( helix ); helix = getappdata(gca,helix); <span class="keyword">end</span>;

plot_settings = getappdata( gca, <span class="string">'plot_settings'</span> );

helix_center = helix.center;
R = get_helix_rotation_matrix( helix );
N = length( helix.resnum1 );
spacing = plot_settings.spacing;
bp_spacing = plot_settings.bp_spacing;
helix_res_tags = {};
<span class="keyword">for</span> k = 1:N
    <span class="comment">% first partner of base pair -- will draw below.</span>
    res_tag = sprintf( <span class="string">'Residue_%s%s%d'</span>, helix.chain1(k), helix.segid1{k}, helix.resnum1(k) );
    pos1 = update_residue_pos( res_tag, [ spacing*((k-1)-(N-1)/2), -bp_spacing/2], helix.center, R );
    helix_res_tags = [helix_res_tags, res_tag ];

    <span class="comment">% second partner of base pair -- will draw below.</span>
    res_tag = sprintf( <span class="string">'Residue_%s%s%d'</span>, helix.chain2(N-k+1), helix.segid1{N-k+1}, helix.resnum2(N-k+1) );
    pos2 = update_residue_pos( res_tag, [ spacing*((k-1)-(N-1)/2), +bp_spacing/2], helix.center, R );
    helix_res_tags = [helix_res_tags, res_tag ];

    all_pos1(k,:) = pos1;
    all_pos2(k,:) = pos2;
<span class="keyword">end</span>

<span class="comment">% draw all residues that are associated with the helix</span>
not_helix_res_tags = {};
<span class="keyword">for</span> i = 1:length( helix.associated_residues )
    res_tag = helix.associated_residues{i};
    residue = getappdata( gca, res_tag );
    <span class="keyword">if</span> ~isfield( residue, <span class="string">'nucleotide'</span> ) <span class="keyword">continue</span>; <span class="keyword">end</span>;
    <span class="keyword">if</span> ~isfield( residue, <span class="string">'relpos'</span> )
        residue.relpos = set_default_relpos( residue, helix, plot_settings );
        setappdata( gca, res_tag, residue );
    <span class="keyword">end</span>;
    draw_residue( res_tag, helix_center, R, plot_settings );
    <span class="keyword">if</span> ~any(strcmp(  helix_res_tags, res_tag )) not_helix_res_tags = [not_helix_res_tags, res_tag]; <span class="keyword">end</span>;
<span class="keyword">end</span>

<span class="comment">% update any linkers associated with these residues</span>
<span class="comment">% in the future, these could include base pairs (incl. non-canonicals)</span>
redrawn_linkers = {};
<span class="keyword">for</span> i = 1:length( helix.associated_residues )
    res_tag = helix.associated_residues{i};
    residue = getappdata( gca, res_tag );
    <span class="keyword">if</span> ~isfield( residue, <span class="string">'linkers'</span> ) <span class="keyword">continue</span>; <span class="keyword">end</span>;
    linker_tags = residue.linkers;
    <span class="comment">% silly cleanup</span>
    <span class="keyword">for</span> k = 1 : length( linker_tags )
        <span class="keyword">if</span> any( strcmp( redrawn_linkers, linker_tags{k} ) ); <span class="keyword">continue</span>; <span class="keyword">end</span>; <span class="comment">% don't double-render, to save time.</span>
        linker = getappdata( gca, linker_tags{k} );
        draw_linker( linker );
        redrawn_linkers = [ redrawn_linkers, linker.linker_tag ];
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">if</span> ~isfield( helix, <span class="string">'label_relpos'</span> ) helix.label_relpos = plot_settings.bp_spacing *[0 1]; <span class="keyword">end</span>;
helix = make_helix_label( helix, plot_settings, R );

<span class="comment">% Selections (if they exist)</span>
selections = {};
<span class="keyword">for</span> i = 1:length( helix.associated_residues )
    res_tag = helix.associated_residues{i};
    residue = getappdata( gca, res_tag );
    <span class="keyword">if</span> isfield( residue, <span class="string">'associated_selections'</span> ) &amp; length( residue.associated_selections ) &gt; 0
        selections = [ selections, residue.associated_selections ];
    <span class="keyword">end</span>
<span class="keyword">end</span>
selections = unique( selections );
draw_selections( selections );

<span class="comment">% handles for helix editing</span>
<span class="comment">% rectangle for dragging.</span>
minpos = min( [all_pos1; all_pos2 ] );
maxpos = max( [all_pos1; all_pos2 ] );
helix = create_default_rectangle( helix, <span class="string">'helix_tag'</span>, helix.helix_tag, @redraw_helix );
set_rectangle_coords( helix, minpos, maxpos, spacing );

<span class="comment">% for helix: clickable line of reflection</span>
<span class="keyword">if</span> ~isfield( helix, <span class="string">'reflect_line1'</span> )
    h = plot( [0 0], [0 0], <span class="string">'color'</span>,[0.5 0.5 1],<span class="string">'clipping'</span>,<span class="string">'off'</span> );
    setappdata( h, <span class="string">'helix_tag'</span>, helix.helix_tag);
    set(h,<span class="string">'ButtonDownFcn'</span>,{@reflect_helix,h});
    helix.reflect_line1 = h;
<span class="keyword">end</span>
line1 = helix_center + spacing*[-(N+0.25)/2, 0]*R;
line1x = helix_center + spacing*[-(N-0.75)/2, 0]*R;
set( helix.reflect_line1, <span class="string">'Xdata'</span>, [line1(1) line1x(1)], <span class="string">'Ydata'</span>, [line1(2) line1x(2)]);

<span class="keyword">if</span> ~isfield( helix, <span class="string">'reflect_line2'</span> )
    h = plot( [0 0], [0 0], <span class="string">'color'</span>,[0.5 0.5 1],<span class="string">'clipping'</span>,<span class="string">'off'</span> );
    setappdata( h, <span class="string">'helix_tag'</span>, helix.helix_tag);
    set(h,<span class="string">'ButtonDownFcn'</span>,{@reflect_helix,h});
    helix.reflect_line2 = h;
<span class="keyword">end</span>
line2 = helix_center + spacing*[ (N+0.25)/2, 0]*R;
line2x = helix_center + spacing*[ (N-0.75)/2, 0]*R;
set( helix.reflect_line2, <span class="string">'Xdata'</span>, [line2(1) line2x(1)], <span class="string">'Ydata'</span>, [line2(2) line2x(2)]);

<span class="comment">% for helix: clickable center of rotation</span>
<span class="keyword">if</span> ~isfield( helix, <span class="string">'click_center'</span> )
    h = rectangle( <span class="string">'Position'</span>,<span class="keyword">...</span>
        [ 0 0 0 0 ], <span class="keyword">...</span>
        <span class="string">'curvature'</span>,[0.5 0.5],<span class="keyword">...</span>
        <span class="string">'edgecolor'</span>,[0.5 0.5 1],<span class="keyword">...</span>
        <span class="string">'facecolor'</span>,[0.5 0.5 1],<span class="string">'linewidth'</span>,1.5,<span class="string">'clipping'</span>,<span class="string">'off'</span> );
    setappdata( h,<span class="string">'helix_tag'</span>, helix.helix_tag);
    set(h,<span class="string">'ButtonDownFcn'</span>,{@rotate_helix,h});
    helix.click_center = h;
<span class="keyword">end</span>
set( helix.click_center, <span class="string">'Position'</span>, [helix_center(1)-0.15*spacing helix_center(2)-0.15*spacing,<span class="keyword">...</span>
    0.3*spacing 0.3*spacing]);

<span class="comment">% make ticklabels draggable</span>
<span class="keyword">for</span> i = 1:length( helix.associated_residues )
    res_tag = helix.associated_residues{i};
    residue = getappdata( gca, res_tag );
    <span class="keyword">if</span> isfield( residue, <span class="string">'tick_label'</span> ) &amp; isvalid( residue.tick_label )
        setappdata( residue.tick_label, <span class="string">'res_tag'</span>, res_tag );
        draggable( residue.tick_label, @move_tick, <span class="string">'endfcn'</span>, @redraw_tick_res_and_helix );
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% make single-stranded residues draggable...</span>
<span class="keyword">for</span> i = 1:length( not_helix_res_tags )
    res_tag = not_helix_res_tags{i};
    residue = getappdata( gca, res_tag );
    draggable( residue.handle,<span class="string">'n'</span>,[-inf inf -inf inf],@move_snapgrid, <span class="string">'endfcn'</span>, @redraw_res_and_helix )
<span class="keyword">end</span>


<span class="comment">%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">% DO THIS AT THE END</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">% 'global data' (stored in figure)</span>
setappdata( gca, helix.helix_tag, helix );

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">% Helper functions</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">% Residue</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="keyword">function</span> h = draw_residue( res_tag, helix_center, R, plot_settings );
residue = getappdata( gca, res_tag );
<span class="keyword">if</span> isfield( residue, <span class="string">'relpos'</span> )
    pos = helix_center +  residue.relpos * R ;
    <span class="keyword">if</span> ~isfield( residue, <span class="string">'handle'</span> ) | ~isvalid( residue.handle )
        residue.handle = text( <span class="keyword">...</span>
            0, 0,<span class="keyword">...</span>
            residue.nucleotide,<span class="keyword">...</span>
            <span class="string">'fontsize'</span>, plot_settings.fontsize, <span class="keyword">...</span>
            <span class="string">'fontname'</span>,<span class="string">'helvetica'</span>,<span class="string">'horizontalalign'</span>,<span class="string">'center'</span>,<span class="string">'verticalalign'</span>,<span class="string">'middle'</span>,<span class="keyword">...</span>
            <span class="string">'clipping'</span>,<span class="string">'off'</span>);
        <span class="keyword">if</span> isfield( plot_settings, <span class="string">'boldface'</span> )
            <span class="keyword">if</span> plot_settings.boldface == 1; fontweight = <span class="string">'bold'</span>; <span class="keyword">else</span>; fontweight = <span class="string">'normal'</span>; <span class="keyword">end</span>;
            set( residue.handle, <span class="string">'fontweight'</span>,fontweight );
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> ( plot_settings.fontsize ~= get( residue.handle, <span class="string">'fontsize'</span> ) ) set( residue.handle, <span class="string">'fontsize'</span>, plot_settings.fontsize ); <span class="keyword">end</span>;
    h = residue.handle;
    set( h, <span class="string">'Position'</span>, pos );
    <span class="keyword">if</span> ( length( residue.nucleotide ) &gt; 1 ) set( h, <span class="string">'fontsize'</span>, plot_settings.fontsize*4/5); <span class="keyword">end</span>;
    setappdata( residue.handle, <span class="string">'res_tag'</span>, res_tag );
    residue.res_tag = res_tag;
    residue.plot_pos = pos;
    <span class="keyword">if</span> isfield( residue, <span class="string">'rgb_color'</span> ) set(h,<span class="string">'color'</span>,residue.rgb_color ); <span class="keyword">end</span>;
    residue = draw_tick( residue, plot_settings.bp_spacing, plot_settings.fontsize, R );
    <span class="comment">% quick linker cleanup</span>
    <span class="keyword">if</span> isfield( residue, <span class="string">'linkers'</span> );
        linker_tags = residue.linkers;
        ok_linker = zeros(1,length(linker_tags));
        <span class="keyword">for</span> k = 1 : length( linker_tags );  ok_linker(k) = isappdata( gca, linker_tags{k} );     <span class="keyword">end</span>
        residue.linkers = linker_tags( find(ok_linker) );
    <span class="keyword">end</span>
    <span class="keyword">if</span> isfield( residue, <span class="string">'image_boundary'</span> );
        residue = draw_image_boundary( residue );
    <span class="keyword">end</span>
    setappdata( gca, res_tag, residue );
<span class="keyword">end</span>


<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="keyword">function</span> relpos = set_default_relpos( residue, helix, plot_settings )
<span class="comment">% need to find which helix st;rand to append to, and then go out a bit.</span>
dist1 = min( abs(helix.resnum1 - residue.resnum) );
<span class="keyword">if</span> ( residue.chain ~= helix.chain1(1) ) dist1 = Inf * dist1; <span class="keyword">end</span>;
dist2 = min( abs(helix.resnum2 - residue.resnum) );
<span class="keyword">if</span> ( residue.chain ~= helix.chain2(1) ) dist2 = Inf * dist2; <span class="keyword">end</span>;
[~,strand] = min( [min( dist1 ), min( dist2 )] );
N = length( helix.resnum1 );
<span class="keyword">if</span> ( strand == 1 )
    d = residue.resnum-helix.resnum1(1);
    <span class="keyword">if</span> abs(d) &gt; 10; d = sign(d) * 10 * ( log( abs(d)/ 10) + 1 );  <span class="keyword">end</span>;
    relpos = [ plot_settings.spacing*(d-(N-1)/2), -plot_settings.bp_spacing/2];
<span class="keyword">else</span>
    assert( strand == 2 );
    d = residue.resnum-helix.resnum2(1);
    <span class="keyword">if</span> abs(d) &gt; 10; d = sign(d) * 10 * ( log( abs(d)/ 10) + 1 );  <span class="keyword">end</span>;
    relpos = [ plot_settings.spacing*(-d+(N-1)/2), +plot_settings.bp_spacing/2];
<span class="keyword">end</span>

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="keyword">function</span> pos = update_residue_pos( res_tag, relpos, center, R );
residue = getappdata( gca, res_tag );
residue.relpos = relpos;
pos = center + relpos*R;
setappdata( gca, res_tag, residue);


<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">% Helix label</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="keyword">function</span> helix = make_helix_label( helix, plot_settings, R )
<span class="comment">% make label</span>
<span class="keyword">if</span> ~isfield( helix, <span class="string">'label'</span> ) | ~isvalid( helix.label)
    h = text( 0,0, helix.name,<span class="keyword">...</span>
        <span class="string">'fontsize'</span>, plot_settings.fontsize*1.5, <span class="string">'fontname'</span>,<span class="string">'helvetica'</span>,<span class="string">'clipping'</span>,<span class="string">'off'</span>);
    helix.label = h;
    <span class="comment">% draggable helix label</span>
    setappdata( helix.label, <span class="string">'helix_tag'</span>, helix.helix_tag );
    draggable( helix.label, <span class="string">'n'</span>,[-inf inf -inf inf], @move_helix_label, <span class="string">'endfcn'</span>, @redraw_helix_label )
<span class="keyword">end</span>
h = helix.label;
label_pos = helix.center + helix.label_relpos * R;
set( h, <span class="string">'String'</span>, helix.name );
set( h, <span class="string">'position'</span>, label_pos );
set( h, <span class="string">'fontsize'</span>, plot_settings.fontsize*1.5 );
<span class="keyword">if</span> isfield( helix, <span class="string">'rgb_color'</span> ) set( h, <span class="string">'color'</span>, helix.rgb_color ); <span class="keyword">end</span>;
v = [0,sign(helix.label_relpos(2))]*R;
set_text_alignment( h, v );
<span class="keyword">if</span> isfield( helix, <span class="string">'label_visible'</span> )
    <span class="keyword">if</span> helix.label_visible; visible = <span class="string">'on'</span>; <span class="keyword">else</span>; visible = <span class="string">'off'</span>; <span class="keyword">end</span>;
    set( helix.label, <span class="string">'visible'</span>, visible );
<span class="keyword">end</span>


<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="keyword">function</span> move_helix_label(h)
pos = get(h,<span class="string">'position'</span>);
helix_tag = getappdata( h, <span class="string">'helix_tag'</span> );
helix = getappdata( gca, helix_tag );
R = get_helix_rotation_matrix( helix );
relpos = (pos(1:2) - helix.center)*R';
v = [0,sign(relpos(2))]*R;
set_text_alignment( h, v );

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="keyword">function</span> redraw_helix_label(h)

pos = get(h,<span class="string">'position'</span>);
helix_tag = getappdata( h, <span class="string">'helix_tag'</span> );
helix = getappdata( gca, helix_tag );

<span class="comment">% need to figure out rel_pos back in the 'frame' of the helix.</span>
<span class="comment">% for that I need to figure out rotation matrix.</span>
R = get_helix_rotation_matrix( helix );
helix.label_relpos = ( pos(1:2) - helix.center ) * R';

<span class="comment">% snap to grid?</span>
plot_settings = getappdata( gca, <span class="string">'plot_settings'</span> );
snap_spacing = plot_settings.bp_spacing/4;
helix.label_relpos = round( helix.label_relpos / snap_spacing ) * snap_spacing;

draw_helix( helix );

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">% Ticks</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="keyword">function</span> residue = draw_tick( residue, bp_spacing, fontsize, R )

<span class="keyword">if</span> ( mod(residue.resnum,10) ~= 0 ); <span class="keyword">return</span>; <span class="keyword">end</span>;
<span class="keyword">if</span> isfield(residue,<span class="string">'ligand_partners'</span>); <span class="keyword">return</span>; <span class="keyword">end</span>;

<span class="keyword">if</span> ~isfield( residue, <span class="string">'tickrot'</span> ) residue.tickrot = nan; <span class="keyword">end</span>; <span class="comment">% nan means set later based on how helix is rotated.</span>

<span class="keyword">if</span> ~isfield( residue, <span class="string">'tick_handle'</span> ) | ~isvalid( residue.tick_handle )
    residue.tick_handle = plot( [0,0],[0,0],<span class="string">'k'</span>,<span class="string">'linewidth'</span>,0.5,<span class="string">'clipping'</span>,<span class="string">'off'</span>); <span class="comment">% dummy for now -- will get redrawn later.</span>
    setappdata( gca, residue.res_tag, residue );
<span class="keyword">end</span>

<span class="keyword">if</span> ~isfield( residue, <span class="string">'tick_label'</span> ) | ~isvalid( residue.tick_label )
    residue.tick_label = text( 0, 0, num2str(residue.resnum), <span class="string">'fontsize'</span>, fontsize,<span class="keyword">...</span>
        <span class="string">'horizontalalign'</span>,<span class="string">'center'</span>,<span class="string">'verticalalign'</span>,<span class="string">'middle'</span>,<span class="string">'clipping'</span>,<span class="string">'off'</span> );
    setappdata( gca, residue.res_tag, residue );
<span class="keyword">end</span>

<span class="keyword">if</span> isfield( residue, <span class="string">'tickrot'</span> )
    <span class="keyword">if</span>  isnan(residue.tickrot) residue = set_default_tickrot( residue ); <span class="keyword">end</span>;
    theta = residue.tickrot;
    v = [cos(theta*pi/180), sin(theta*pi/180)]*R;
    tickpos1 = residue.plot_pos + v*bp_spacing/3;
    tickpos2 = residue.plot_pos + v*bp_spacing*2/3;
    set( residue.tick_handle, <span class="string">'xdata'</span>, [tickpos1(1) tickpos2(1)] );
    set( residue.tick_handle, <span class="string">'ydata'</span>, [tickpos1(2) tickpos2(2)] );
    labelpos = residue.plot_pos + v*bp_spacing*2/3;
    set( residue.tick_label, <span class="string">'position'</span>, labelpos );
    plot_settings = getappdata( gca, <span class="string">'plot_settings'</span> );
    <span class="keyword">if</span> ( get(residue.tick_label, <span class="string">'fontsize'</span>) ~= plot_settings.fontsize )
        set( residue.tick_label, <span class="string">'fontsize'</span>, plot_settings.fontsize );
    <span class="keyword">end</span>;
    set_text_alignment( residue.tick_label, v );
<span class="keyword">end</span>

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="keyword">function</span> residue = set_default_tickrot( residue )
<span class="keyword">if</span> ( sign( residue.relpos(2) ) &gt; 0 )
    residue.tickrot = 90;
<span class="keyword">else</span>
    residue.tickrot = 270;
<span class="keyword">end</span>

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="keyword">function</span> move_tick(h)
<span class="comment">% snap to grid during movement.</span>
pos = get(h,<span class="string">'Position'</span>);
pos = pos(1:2); <span class="comment">% text</span>
residue = getappdata( gca, getappdata(h,<span class="string">'res_tag'</span>) );
v = pos - residue.plot_pos;
theta = atan2( v(2), v(1) );
theta = round(theta*180/pi/45)*45;
v = [cos(theta*pi/180),sin(theta*pi/180)];
plot_settings = getappdata(gca,<span class="string">'plot_settings'</span>);
labelpos = residue.plot_pos + v*plot_settings.bp_spacing*2/3;
set(h,<span class="string">'Position'</span>,labelpos);
set_text_alignment( h, v );

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="keyword">function</span> redraw_tick_res_and_helix(h)

pos = get(h,<span class="string">'Position'</span>);
pos = pos(1:2); <span class="comment">% text</span>

<span class="comment">% position relative to residue will define tickrot</span>
res_tag =  getappdata(h,<span class="string">'res_tag'</span>);
residue = getappdata( gca,res_tag );
v = pos - residue.plot_pos;
helix = getappdata( gca, residue.helix_tag );

<span class="comment">% need to get into 'helix frame';</span>
R = get_helix_rotation_matrix( helix );
v = v*R';
tickrot = mod( round(atan2(v(2),v(1))*180/pi/45)*45, 360 );
residue.tickrot = tickrot;
setappdata( gca, res_tag, residue );

<span class="comment">% shortcut to redraw everything.</span>
redraw_res_and_helix( residue.handle );
</pre><pre class="codeoutput error">Not enough input arguments.

Error in draw_helix (line 5)
if ischar( helix ); helix = getappdata(gca,helix); end;
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016a</a><br></p></div><!--
##### SOURCE BEGIN #####
function helix = draw_helix( helix )
% helix = draw_helix( helix )
% (C) R. Das, Stanford University, 2017

if ischar( helix ); helix = getappdata(gca,helix); end;
    
plot_settings = getappdata( gca, 'plot_settings' );

helix_center = helix.center;
R = get_helix_rotation_matrix( helix ); 
N = length( helix.resnum1 );
spacing = plot_settings.spacing;
bp_spacing = plot_settings.bp_spacing;
helix_res_tags = {};
for k = 1:N
    % first partner of base pair REPLACE_WITH_DASH_DASH will draw below.
    res_tag = sprintf( 'Residue_%s%s%d', helix.chain1(k), helix.segid1{k}, helix.resnum1(k) );
    pos1 = update_residue_pos( res_tag, [ spacing*((k-1)-(N-1)/2), -bp_spacing/2], helix.center, R );
    helix_res_tags = [helix_res_tags, res_tag ];
    
    % second partner of base pair REPLACE_WITH_DASH_DASH will draw below.
    res_tag = sprintf( 'Residue_%s%s%d', helix.chain2(N-k+1), helix.segid1{N-k+1}, helix.resnum2(N-k+1) );
    pos2 = update_residue_pos( res_tag, [ spacing*((k-1)-(N-1)/2), +bp_spacing/2], helix.center, R );
    helix_res_tags = [helix_res_tags, res_tag ];
    
    all_pos1(k,:) = pos1;
    all_pos2(k,:) = pos2;
end

% draw all residues that are associated with the helix 
not_helix_res_tags = {};
for i = 1:length( helix.associated_residues )
    res_tag = helix.associated_residues{i};
    residue = getappdata( gca, res_tag );
    if ~isfield( residue, 'nucleotide' ) continue; end;
    if ~isfield( residue, 'relpos' ) 
        residue.relpos = set_default_relpos( residue, helix, plot_settings ); 
        setappdata( gca, res_tag, residue );
    end;
    draw_residue( res_tag, helix_center, R, plot_settings );
    if ~any(strcmp(  helix_res_tags, res_tag )) not_helix_res_tags = [not_helix_res_tags, res_tag]; end;
end

% update any linkers associated with these residues
% in the future, these could include base pairs (incl. non-canonicals)
redrawn_linkers = {};
for i = 1:length( helix.associated_residues )
    res_tag = helix.associated_residues{i};
    residue = getappdata( gca, res_tag );
    if ~isfield( residue, 'linkers' ) continue; end;
    linker_tags = residue.linkers;
    % silly cleanup
    for k = 1 : length( linker_tags )
        if any( strcmp( redrawn_linkers, linker_tags{k} ) ); continue; end; % don't double-render, to save time.
        linker = getappdata( gca, linker_tags{k} );
        draw_linker( linker );
        redrawn_linkers = [ redrawn_linkers, linker.linker_tag ];
    end
end

if ~isfield( helix, 'label_relpos' ) helix.label_relpos = plot_settings.bp_spacing *[0 1]; end;
helix = make_helix_label( helix, plot_settings, R );

% Selections (if they exist)
selections = {};
for i = 1:length( helix.associated_residues )
    res_tag = helix.associated_residues{i};
    residue = getappdata( gca, res_tag );
    if isfield( residue, 'associated_selections' ) & length( residue.associated_selections ) > 0
        selections = [ selections, residue.associated_selections ];
    end    
end
selections = unique( selections );
draw_selections( selections );

% handles for helix editing
% rectangle for dragging.
minpos = min( [all_pos1; all_pos2 ] );
maxpos = max( [all_pos1; all_pos2 ] );
helix = create_default_rectangle( helix, 'helix_tag', helix.helix_tag, @redraw_helix );
set_rectangle_coords( helix, minpos, maxpos, spacing );

% for helix: clickable line of reflection
if ~isfield( helix, 'reflect_line1' )
    h = plot( [0 0], [0 0], 'color',[0.5 0.5 1],'clipping','off' );
    setappdata( h, 'helix_tag', helix.helix_tag);
    set(h,'ButtonDownFcn',{@reflect_helix,h});
    helix.reflect_line1 = h;
end
line1 = helix_center + spacing*[-(N+0.25)/2, 0]*R;
line1x = helix_center + spacing*[-(N-0.75)/2, 0]*R;
set( helix.reflect_line1, 'Xdata', [line1(1) line1x(1)], 'Ydata', [line1(2) line1x(2)]);

if ~isfield( helix, 'reflect_line2' )
    h = plot( [0 0], [0 0], 'color',[0.5 0.5 1],'clipping','off' );
    setappdata( h, 'helix_tag', helix.helix_tag);
    set(h,'ButtonDownFcn',{@reflect_helix,h});
    helix.reflect_line2 = h;
end
line2 = helix_center + spacing*[ (N+0.25)/2, 0]*R;
line2x = helix_center + spacing*[ (N-0.75)/2, 0]*R;
set( helix.reflect_line2, 'Xdata', [line2(1) line2x(1)], 'Ydata', [line2(2) line2x(2)]);

% for helix: clickable center of rotation
if ~isfield( helix, 'click_center' )
    h = rectangle( 'Position',...
        [ 0 0 0 0 ], ...
        'curvature',[0.5 0.5],...
        'edgecolor',[0.5 0.5 1],...
        'facecolor',[0.5 0.5 1],'linewidth',1.5,'clipping','off' );
    setappdata( h,'helix_tag', helix.helix_tag);
    set(h,'ButtonDownFcn',{@rotate_helix,h});
    helix.click_center = h;
end
set( helix.click_center, 'Position', [helix_center(1)-0.15*spacing helix_center(2)-0.15*spacing,...
    0.3*spacing 0.3*spacing]);

% make ticklabels draggable
for i = 1:length( helix.associated_residues )
    res_tag = helix.associated_residues{i};
    residue = getappdata( gca, res_tag );
    if isfield( residue, 'tick_label' ) & isvalid( residue.tick_label )
        setappdata( residue.tick_label, 'res_tag', res_tag );
        draggable( residue.tick_label, @move_tick, 'endfcn', @redraw_tick_res_and_helix );
    end
end

% make single-stranded residues draggable...
for i = 1:length( not_helix_res_tags )
    res_tag = not_helix_res_tags{i};
    residue = getappdata( gca, res_tag );
    draggable( residue.handle,'n',[-inf inf -inf inf],@move_snapgrid, 'endfcn', @redraw_res_and_helix )
end


%%%%%%%%%%%%%%%%%%%%%
% DO THIS AT THE END
%%%%%%%%%%%%%%%%%%%%%
% 'global data' (stored in figure)
setappdata( gca, helix.helix_tag, helix );

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Helper functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Residue 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function h = draw_residue( res_tag, helix_center, R, plot_settings );
residue = getappdata( gca, res_tag );
if isfield( residue, 'relpos' ) 
    pos = helix_center +  residue.relpos * R ;
    if ~isfield( residue, 'handle' ) | ~isvalid( residue.handle )
        residue.handle = text( ...
            0, 0,...
            residue.nucleotide,...
            'fontsize', plot_settings.fontsize, ...
            'fontname','helvetica','horizontalalign','center','verticalalign','middle',...
            'clipping','off');
        if isfield( plot_settings, 'boldface' )
            if plot_settings.boldface == 1; fontweight = 'bold'; else; fontweight = 'normal'; end;
            set( residue.handle, 'fontweight',fontweight );
        end
    end
    if ( plot_settings.fontsize ~= get( residue.handle, 'fontsize' ) ) set( residue.handle, 'fontsize', plot_settings.fontsize ); end;
    h = residue.handle;
    set( h, 'Position', pos );
    if ( length( residue.nucleotide ) > 1 ) set( h, 'fontsize', plot_settings.fontsize*4/5); end;
    setappdata( residue.handle, 'res_tag', res_tag );
    residue.res_tag = res_tag;
    residue.plot_pos = pos;
    if isfield( residue, 'rgb_color' ) set(h,'color',residue.rgb_color ); end;
    residue = draw_tick( residue, plot_settings.bp_spacing, plot_settings.fontsize, R );
    % quick linker cleanup
    if isfield( residue, 'linkers' );
        linker_tags = residue.linkers;
        ok_linker = zeros(1,length(linker_tags));
        for k = 1 : length( linker_tags );  ok_linker(k) = isappdata( gca, linker_tags{k} );     end
        residue.linkers = linker_tags( find(ok_linker) );
    end
    if isfield( residue, 'image_boundary' );
        residue = draw_image_boundary( residue );
    end
    setappdata( gca, res_tag, residue );
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function relpos = set_default_relpos( residue, helix, plot_settings )
% need to find which helix st;rand to append to, and then go out a bit.
dist1 = min( abs(helix.resnum1 - residue.resnum) );
if ( residue.chain ~= helix.chain1(1) ) dist1 = Inf * dist1; end;
dist2 = min( abs(helix.resnum2 - residue.resnum) );
if ( residue.chain ~= helix.chain2(1) ) dist2 = Inf * dist2; end;
[~,strand] = min( [min( dist1 ), min( dist2 )] );
N = length( helix.resnum1 );
if ( strand == 1 )   
    d = residue.resnum-helix.resnum1(1);
    if abs(d) > 10; d = sign(d) * 10 * ( log( abs(d)/ 10) + 1 );  end;
    relpos = [ plot_settings.spacing*(d-(N-1)/2), -plot_settings.bp_spacing/2];
else
    assert( strand == 2 );    
    d = residue.resnum-helix.resnum2(1);
    if abs(d) > 10; d = sign(d) * 10 * ( log( abs(d)/ 10) + 1 );  end;
    relpos = [ plot_settings.spacing*(-d+(N-1)/2), +plot_settings.bp_spacing/2];  
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function pos = update_residue_pos( res_tag, relpos, center, R );
residue = getappdata( gca, res_tag );
residue.relpos = relpos;
pos = center + relpos*R;
setappdata( gca, res_tag, residue);
        

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Helix label
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function helix = make_helix_label( helix, plot_settings, R )
% make label
if ~isfield( helix, 'label' ) | ~isvalid( helix.label)
    h = text( 0,0, helix.name,...
        'fontsize', plot_settings.fontsize*1.5, 'fontname','helvetica','clipping','off');
    helix.label = h;
    % draggable helix label
    setappdata( helix.label, 'helix_tag', helix.helix_tag );
    draggable( helix.label, 'n',[-inf inf -inf inf], @move_helix_label, 'endfcn', @redraw_helix_label )
end
h = helix.label;
label_pos = helix.center + helix.label_relpos * R;
set( h, 'String', helix.name );
set( h, 'position', label_pos );
set( h, 'fontsize', plot_settings.fontsize*1.5 );
if isfield( helix, 'rgb_color' ) set( h, 'color', helix.rgb_color ); end;
v = [0,sign(helix.label_relpos(2))]*R;
set_text_alignment( h, v );
if isfield( helix, 'label_visible' )
    if helix.label_visible; visible = 'on'; else; visible = 'off'; end;
    set( helix.label, 'visible', visible );
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function move_helix_label(h)
pos = get(h,'position'); 
helix_tag = getappdata( h, 'helix_tag' );
helix = getappdata( gca, helix_tag );
R = get_helix_rotation_matrix( helix );
relpos = (pos(1:2) - helix.center)*R';
v = [0,sign(relpos(2))]*R;
set_text_alignment( h, v );

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function redraw_helix_label(h)

pos = get(h,'position'); 
helix_tag = getappdata( h, 'helix_tag' );
helix = getappdata( gca, helix_tag );

% need to figure out rel_pos back in the 'frame' of the helix.
% for that I need to figure out rotation matrix.
R = get_helix_rotation_matrix( helix );
helix.label_relpos = ( pos(1:2) - helix.center ) * R';

% snap to grid?
plot_settings = getappdata( gca, 'plot_settings' );
snap_spacing = plot_settings.bp_spacing/4;
helix.label_relpos = round( helix.label_relpos / snap_spacing ) * snap_spacing;

draw_helix( helix );

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Ticks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function residue = draw_tick( residue, bp_spacing, fontsize, R )

if ( mod(residue.resnum,10) ~= 0 ); return; end;
if isfield(residue,'ligand_partners'); return; end;

if ~isfield( residue, 'tickrot' ) residue.tickrot = nan; end; % nan means set later based on how helix is rotated.

if ~isfield( residue, 'tick_handle' ) | ~isvalid( residue.tick_handle )
    residue.tick_handle = plot( [0,0],[0,0],'k','linewidth',0.5,'clipping','off'); % dummy for now REPLACE_WITH_DASH_DASH will get redrawn later.
    setappdata( gca, residue.res_tag, residue );
end

if ~isfield( residue, 'tick_label' ) | ~isvalid( residue.tick_label )
    residue.tick_label = text( 0, 0, num2str(residue.resnum), 'fontsize', fontsize,...
        'horizontalalign','center','verticalalign','middle','clipping','off' );
    setappdata( gca, residue.res_tag, residue );
end

if isfield( residue, 'tickrot' ) 
    if  isnan(residue.tickrot) residue = set_default_tickrot( residue ); end;
    theta = residue.tickrot;
    v = [cos(theta*pi/180), sin(theta*pi/180)]*R;
    tickpos1 = residue.plot_pos + v*bp_spacing/3; 
    tickpos2 = residue.plot_pos + v*bp_spacing*2/3;
    set( residue.tick_handle, 'xdata', [tickpos1(1) tickpos2(1)] );
    set( residue.tick_handle, 'ydata', [tickpos1(2) tickpos2(2)] );
    labelpos = residue.plot_pos + v*bp_spacing*2/3;
    set( residue.tick_label, 'position', labelpos );
    plot_settings = getappdata( gca, 'plot_settings' );
    if ( get(residue.tick_label, 'fontsize') ~= plot_settings.fontsize ) 
        set( residue.tick_label, 'fontsize', plot_settings.fontsize );  
    end;
    set_text_alignment( residue.tick_label, v );
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function residue = set_default_tickrot( residue )
if ( sign( residue.relpos(2) ) > 0 ) 
    residue.tickrot = 90;
else
    residue.tickrot = 270;
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function move_tick(h)
% snap to grid during movement.
pos = get(h,'Position');
pos = pos(1:2); % text
residue = getappdata( gca, getappdata(h,'res_tag') );
v = pos - residue.plot_pos;
theta = atan2( v(2), v(1) );
theta = round(theta*180/pi/45)*45;
v = [cos(theta*pi/180),sin(theta*pi/180)];
plot_settings = getappdata(gca,'plot_settings');
labelpos = residue.plot_pos + v*plot_settings.bp_spacing*2/3;
set(h,'Position',labelpos);
set_text_alignment( h, v );

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function redraw_tick_res_and_helix(h)

pos = get(h,'Position');
pos = pos(1:2); % text

% position relative to residue will define tickrot
res_tag =  getappdata(h,'res_tag');
residue = getappdata( gca,res_tag );
v = pos - residue.plot_pos;
helix = getappdata( gca, residue.helix_tag );

% need to get into 'helix frame';
R = get_helix_rotation_matrix( helix );
v = v*R'; 
tickrot = mod( round(atan2(v(2),v(1))*180/pi/45)*45, 360 );
residue.tickrot = tickrot;
setappdata( gca, res_tag, residue );

% shortcut to redraw everything.
redraw_res_and_helix( residue.handle );


##### SOURCE END #####
--></body></html>