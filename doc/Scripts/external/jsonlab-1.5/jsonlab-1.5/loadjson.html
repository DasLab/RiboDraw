<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of loadjson</title>
  <meta name="keywords" content="loadjson">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../index.html">Home</a> &gt;  <a href="#">Scripts</a> &gt; <a href="#">external</a> &gt; <a href="#">jsonlab-1.5</a> &gt; <a href="index.html">jsonlab-1.5</a> &gt; loadjson.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../index.html"><img alt="<" border="0" src="../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for Scripts/external/jsonlab-1.5/jsonlab-1.5&nbsp;<img alt=">" border="0" src="../../../../right.png"></a></td></tr></table>-->

<h1>loadjson
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function data = loadjson(fname,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">
 data=loadjson(fname,opt)
    or
 data=loadjson(fname,'param1',value1,'param2',value2,...)

 parse a JSON (JavaScript Object Notation) file or string

 authors:Qianqian Fang (q.fang &lt;at&gt; neu.edu)
 created on 2011/09/09, including previous works from 

         Nedialko Krouchev: http://www.mathworks.com/matlabcentral/fileexchange/25713
            created on 2009/11/02
         François Glineur: http://www.mathworks.com/matlabcentral/fileexchange/23393
            created on  2009/03/22
         Joel Feenstra:
         http://www.mathworks.com/matlabcentral/fileexchange/20565
            created on 2008/07/03

 $Id$

 input:
      fname: input file name, if fname contains &quot;{}&quot; or &quot;[]&quot;, fname
             will be interpreted as a JSON string
      opt: a struct to store parsing options, opt can be replaced by 
           a list of ('param',value) pairs - the param string is equivallent
           to a field in opt. opt can have the following 
           fields (first in [.|.] is the default)

           opt.SimplifyCell [0|1]: if set to 1, loadjson will call cell2mat
                         for each element of the JSON data, and group 
                         arrays based on the cell2mat rules.
           opt.FastArrayParser [1|0 or integer]: if set to 1, use a
                         speed-optimized array parser when loading an 
                         array object. The fast array parser may 
                         collapse block arrays into a single large
                         array similar to rules defined in cell2mat; 0 to 
                         use a legacy parser; if set to a larger-than-1
                         value, this option will specify the minimum
                         dimension to enable the fast array parser. For
                         example, if the input is a 3D array, setting
                         FastArrayParser to 1 will return a 3D array;
                         setting to 2 will return a cell array of 2D
                         arrays; setting to 3 will return to a 2D cell
                         array of 1D vectors; setting to 4 will return a
                         3D cell array.
           opt.ShowProgress [0|1]: if set to 1, loadjson displays a progress bar.

 output:
      dat: a cell array, where {...} blocks are converted into cell arrays,
           and [...] are converted to arrays

 examples:
      dat=loadjson('{&quot;obj&quot;:{&quot;string&quot;:&quot;value&quot;,&quot;array&quot;:[1,2,3]}}')
      dat=loadjson(['examples' filesep 'example1.json'])
      dat=loadjson(['examples' filesep 'example1.json'],'SimplifyCell',1)

 license:
     BSD License, see LICENSE_BSD.txt files for details 

 -- this function is part of JSONLab toolbox (http://iso2mesh.sf.net/cgi-bin/index.cgi?jsonlab)</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>	</li><li><a href="struct2jdata.html" class="code" title="function newdata=struct2jdata(data,varargin)">struct2jdata</a>	</li><li><a href="varargin2struct.html" class="code" title="function opt=varargin2struct(varargin)">varargin2struct</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function object = parse_object(inStr, esc, varargin)</a></li><li><a href="#_sub2" class="code">function object = parse_array(inStr, esc, varargin)</a></li><li><a href="#_sub3" class="code">function parse_char(inStr, c)</a></li><li><a href="#_sub4" class="code">function c = next_char(inStr)</a></li><li><a href="#_sub5" class="code">function newpos=skip_whitespace(pos, inStr)</a></li><li><a href="#_sub6" class="code">function str = parseStr(inStr, esc, varargin)</a></li><li><a href="#_sub7" class="code">function num = parse_number(inStr, varargin)</a></li><li><a href="#_sub8" class="code">function val = parse_value(inStr, esc, varargin)</a></li><li><a href="#_sub9" class="code">function error_pos(msg, inStr)</a></li><li><a href="#_sub10" class="code">function str = valid_field(str)</a></li><li><a href="#_sub11" class="code">function endpos = matching_quote(str,pos)</a></li><li><a href="#_sub12" class="code">function [endpos, e1l, e1r, maxlevel] = matching_bracket(str,pos)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function data = loadjson(fname,varargin)</a>
0002 <span class="comment">%</span>
0003 <span class="comment">% data=loadjson(fname,opt)</span>
0004 <span class="comment">%    or</span>
0005 <span class="comment">% data=loadjson(fname,'param1',value1,'param2',value2,...)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% parse a JSON (JavaScript Object Notation) file or string</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% authors:Qianqian Fang (q.fang &lt;at&gt; neu.edu)</span>
0010 <span class="comment">% created on 2011/09/09, including previous works from</span>
0011 <span class="comment">%</span>
0012 <span class="comment">%         Nedialko Krouchev: http://www.mathworks.com/matlabcentral/fileexchange/25713</span>
0013 <span class="comment">%            created on 2009/11/02</span>
0014 <span class="comment">%         François Glineur: http://www.mathworks.com/matlabcentral/fileexchange/23393</span>
0015 <span class="comment">%            created on  2009/03/22</span>
0016 <span class="comment">%         Joel Feenstra:</span>
0017 <span class="comment">%         http://www.mathworks.com/matlabcentral/fileexchange/20565</span>
0018 <span class="comment">%            created on 2008/07/03</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% $Id$</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% input:</span>
0023 <span class="comment">%      fname: input file name, if fname contains &quot;{}&quot; or &quot;[]&quot;, fname</span>
0024 <span class="comment">%             will be interpreted as a JSON string</span>
0025 <span class="comment">%      opt: a struct to store parsing options, opt can be replaced by</span>
0026 <span class="comment">%           a list of ('param',value) pairs - the param string is equivallent</span>
0027 <span class="comment">%           to a field in opt. opt can have the following</span>
0028 <span class="comment">%           fields (first in [.|.] is the default)</span>
0029 <span class="comment">%</span>
0030 <span class="comment">%           opt.SimplifyCell [0|1]: if set to 1, loadjson will call cell2mat</span>
0031 <span class="comment">%                         for each element of the JSON data, and group</span>
0032 <span class="comment">%                         arrays based on the cell2mat rules.</span>
0033 <span class="comment">%           opt.FastArrayParser [1|0 or integer]: if set to 1, use a</span>
0034 <span class="comment">%                         speed-optimized array parser when loading an</span>
0035 <span class="comment">%                         array object. The fast array parser may</span>
0036 <span class="comment">%                         collapse block arrays into a single large</span>
0037 <span class="comment">%                         array similar to rules defined in cell2mat; 0 to</span>
0038 <span class="comment">%                         use a legacy parser; if set to a larger-than-1</span>
0039 <span class="comment">%                         value, this option will specify the minimum</span>
0040 <span class="comment">%                         dimension to enable the fast array parser. For</span>
0041 <span class="comment">%                         example, if the input is a 3D array, setting</span>
0042 <span class="comment">%                         FastArrayParser to 1 will return a 3D array;</span>
0043 <span class="comment">%                         setting to 2 will return a cell array of 2D</span>
0044 <span class="comment">%                         arrays; setting to 3 will return to a 2D cell</span>
0045 <span class="comment">%                         array of 1D vectors; setting to 4 will return a</span>
0046 <span class="comment">%                         3D cell array.</span>
0047 <span class="comment">%           opt.ShowProgress [0|1]: if set to 1, loadjson displays a progress bar.</span>
0048 <span class="comment">%</span>
0049 <span class="comment">% output:</span>
0050 <span class="comment">%      dat: a cell array, where {...} blocks are converted into cell arrays,</span>
0051 <span class="comment">%           and [...] are converted to arrays</span>
0052 <span class="comment">%</span>
0053 <span class="comment">% examples:</span>
0054 <span class="comment">%      dat=loadjson('{&quot;obj&quot;:{&quot;string&quot;:&quot;value&quot;,&quot;array&quot;:[1,2,3]}}')</span>
0055 <span class="comment">%      dat=loadjson(['examples' filesep 'example1.json'])</span>
0056 <span class="comment">%      dat=loadjson(['examples' filesep 'example1.json'],'SimplifyCell',1)</span>
0057 <span class="comment">%</span>
0058 <span class="comment">% license:</span>
0059 <span class="comment">%     BSD License, see LICENSE_BSD.txt files for details</span>
0060 <span class="comment">%</span>
0061 <span class="comment">% -- this function is part of JSONLab toolbox (http://iso2mesh.sf.net/cgi-bin/index.cgi?jsonlab)</span>
0062 <span class="comment">%</span>
0063 
0064 <span class="keyword">global</span> pos index_esc isoct arraytoken
0065 
0066 <span class="keyword">if</span>(regexp(fname,<span class="string">'^\s*(?:\[.*\])|(?:\{.*\})\s*$'</span>,<span class="string">'once'</span>))
0067    string=fname;
0068 <span class="keyword">elseif</span>(exist(fname,<span class="string">'file'</span>))
0069    <span class="keyword">try</span>
0070        string = fileread(fname);
0071    <span class="keyword">catch</span>
0072        <span class="keyword">try</span>
0073            string = urlread([<span class="string">'file://'</span>,fname]);
0074        <span class="keyword">catch</span>
0075            string = urlread([<span class="string">'file://'</span>,fullfile(pwd,fname)]);
0076        <span class="keyword">end</span>
0077    <span class="keyword">end</span>
0078 <span class="keyword">else</span>
0079    error(<span class="string">'input file does not exist'</span>);
0080 <span class="keyword">end</span>
0081 
0082 pos = 1; len = length(string); inStr = string;
0083 isoct=exist(<span class="string">'OCTAVE_VERSION'</span>,<span class="string">'builtin'</span>);
0084 arraytoken=find(inStr==<span class="string">'['</span> | inStr==<span class="string">']'</span> | inStr==<span class="string">'&quot;'</span>);
0085 jstr=regexprep(inStr,<span class="string">'\\\\'</span>,<span class="string">'  '</span>);
0086 escquote=regexp(jstr,<span class="string">'\\&quot;'</span>);
0087 arraytoken=sort([arraytoken escquote]);
0088 
0089 <span class="comment">% String delimiters and escape chars identified to improve speed:</span>
0090 esc = find(inStr==<span class="string">'&quot;'</span> | inStr==<span class="string">'\'</span> ); <span class="comment">% comparable to: regexp(inStr, '[&quot;\\]');</span>
0091 index_esc = 1;
0092 
0093 opt=<a href="varargin2struct.html" class="code" title="function opt=varargin2struct(varargin)">varargin2struct</a>(varargin{:});
0094 
0095 <span class="keyword">if</span>(<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'ShowProgress'</span>,0,opt)==1)
0096     opt.progressbar_=waitbar(0,<span class="string">'loading ...'</span>);
0097 <span class="keyword">end</span>
0098 jsoncount=1;
0099 <span class="keyword">while</span> pos &lt;= len
0100     <span class="keyword">switch</span>(<a href="#_sub4" class="code" title="subfunction c = next_char(inStr)">next_char</a>(inStr))
0101         <span class="keyword">case</span> <span class="string">'{'</span>
0102             data{jsoncount} = <a href="#_sub1" class="code" title="subfunction object = parse_object(inStr, esc, varargin)">parse_object</a>(inStr, esc, opt);
0103         <span class="keyword">case</span> <span class="string">'['</span>
0104             data{jsoncount} = <a href="#_sub2" class="code" title="subfunction object = parse_array(inStr, esc, varargin) ">parse_array</a>(inStr, esc, opt);
0105         <span class="keyword">otherwise</span>
0106             <a href="#_sub9" class="code" title="subfunction error_pos(msg, inStr)">error_pos</a>(<span class="string">'Outer level structure must be an object or an array'</span>,inStr);
0107     <span class="keyword">end</span>
0108     jsoncount=jsoncount+1;
0109 <span class="keyword">end</span> <span class="comment">% while</span>
0110 
0111 jsoncount=length(data);
0112 <span class="keyword">if</span>(jsoncount==1 &amp;&amp; iscell(data))
0113     data=data{1};
0114 <span class="keyword">end</span>
0115 
0116 <span class="keyword">if</span>(isfield(opt,<span class="string">'progressbar_'</span>))
0117     close(opt.progressbar_);
0118 <span class="keyword">end</span>
0119 
0120 <span class="comment">%%-------------------------------------------------------------------------</span>
0121 <a name="_sub1" href="#_subfunctions" class="code">function object = parse_object(inStr, esc, varargin)</a>
0122     <a href="#_sub3" class="code" title="subfunction parse_char(inStr, c)">parse_char</a>(inStr, <span class="string">'{'</span>);
0123     object = [];
0124     <span class="keyword">if</span> <a href="#_sub4" class="code" title="subfunction c = next_char(inStr)">next_char</a>(inStr) ~= <span class="string">'}'</span>
0125         <span class="keyword">while</span> 1
0126             str = <a href="#_sub6" class="code" title="subfunction str = parseStr(inStr, esc, varargin)">parseStr</a>(inStr, esc, varargin{:});
0127             <span class="keyword">if</span> isempty(str)
0128                 <a href="#_sub9" class="code" title="subfunction error_pos(msg, inStr)">error_pos</a>(<span class="string">'Name of value at position %d cannot be empty'</span>,inStr);
0129             <span class="keyword">end</span>
0130             <a href="#_sub3" class="code" title="subfunction parse_char(inStr, c)">parse_char</a>(inStr, <span class="string">':'</span>);
0131             val = <a href="#_sub8" class="code" title="subfunction val = parse_value(inStr, esc, varargin)">parse_value</a>(inStr, esc, varargin{:});
0132             object.(<a href="#_sub10" class="code" title="subfunction str = valid_field(str)">valid_field</a>(str))=val;
0133             <span class="keyword">if</span> <a href="#_sub4" class="code" title="subfunction c = next_char(inStr)">next_char</a>(inStr) == <span class="string">'}'</span>
0134                 <span class="keyword">break</span>;
0135             <span class="keyword">end</span>
0136             <a href="#_sub3" class="code" title="subfunction parse_char(inStr, c)">parse_char</a>(inStr, <span class="string">','</span>);
0137         <span class="keyword">end</span>
0138     <span class="keyword">end</span>
0139     <a href="#_sub3" class="code" title="subfunction parse_char(inStr, c)">parse_char</a>(inStr, <span class="string">'}'</span>);
0140     <span class="keyword">if</span>(isstruct(object))
0141         object=<a href="struct2jdata.html" class="code" title="function newdata=struct2jdata(data,varargin)">struct2jdata</a>(object);
0142     <span class="keyword">end</span>
0143 
0144 <span class="comment">%%-------------------------------------------------------------------------</span>
0145 
0146 <a name="_sub2" href="#_subfunctions" class="code">function object = parse_array(inStr, esc, varargin) </a><span class="comment">% JSON array is written in row-major order</span>
0147     <span class="keyword">global</span> pos isoct
0148     <a href="#_sub3" class="code" title="subfunction parse_char(inStr, c)">parse_char</a>(inStr, <span class="string">'['</span>);
0149     object = cell(0, 1);
0150     dim2=[];
0151     arraydepth=<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'JSONLAB_ArrayDepth_'</span>,1,varargin{:});
0152     pbar=-1;
0153     <span class="keyword">if</span>(isfield(varargin{1},<span class="string">'progressbar_'</span>))
0154         pbar=varargin{1}.progressbar_;
0155     <span class="keyword">end</span>
0156 
0157     <span class="keyword">if</span> <a href="#_sub4" class="code" title="subfunction c = next_char(inStr)">next_char</a>(inStr) ~= <span class="string">']'</span>
0158     <span class="keyword">if</span>(<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'FastArrayParser'</span>,1,varargin{:})&gt;=1 &amp;&amp; arraydepth&gt;=<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'FastArrayParser'</span>,1,varargin{:}))
0159             [endpos, e1l, e1r]=<a href="#_sub12" class="code" title="subfunction [endpos, e1l, e1r, maxlevel] = matching_bracket(str,pos)">matching_bracket</a>(inStr,pos);
0160             arraystr=[<span class="string">'['</span> inStr(pos:endpos)];
0161             arraystr=regexprep(arraystr,<span class="string">'&quot;_NaN_&quot;'</span>,<span class="string">'NaN'</span>);
0162             arraystr=regexprep(arraystr,<span class="string">'&quot;([-+]*)_Inf_&quot;'</span>,<span class="string">'$1Inf'</span>);
0163             arraystr(arraystr==sprintf(<span class="string">'\n'</span>))=[];
0164             arraystr(arraystr==sprintf(<span class="string">'\r'</span>))=[];
0165             <span class="comment">%arraystr=regexprep(arraystr,'\s*,',','); % this is slow,sometimes needed</span>
0166             <span class="keyword">if</span>(~isempty(e1l) &amp;&amp; ~isempty(e1r)) <span class="comment">% the array is in 2D or higher D</span>
0167             astr=inStr((e1l+1):(e1r-1));
0168             astr=regexprep(astr,<span class="string">'&quot;_NaN_&quot;'</span>,<span class="string">'NaN'</span>);
0169             astr=regexprep(astr,<span class="string">'&quot;([-+]*)_Inf_&quot;'</span>,<span class="string">'$1Inf'</span>);
0170             astr(astr==sprintf(<span class="string">'\n'</span>))=[];
0171             astr(astr==sprintf(<span class="string">'\r'</span>))=[];
0172             astr(astr==<span class="string">' '</span>)=<span class="string">''</span>;
0173             <span class="keyword">if</span>(isempty(find(astr==<span class="string">'['</span>, 1))) <span class="comment">% array is 2D</span>
0174                     dim2=length(sscanf(astr,<span class="string">'%f,'</span>,[1 inf]));
0175             <span class="keyword">end</span>
0176             <span class="keyword">else</span> <span class="comment">% array is 1D</span>
0177             astr=arraystr(2:end-1);
0178             astr(astr==<span class="string">' '</span>)=<span class="string">''</span>;
0179             [obj, count, errmsg, nextidx]=sscanf(astr,<span class="string">'%f,'</span>,[1,inf]);
0180             <span class="keyword">if</span>(nextidx&gt;=length(astr)-1)
0181                     object=obj;
0182                     pos=endpos;
0183                     <a href="#_sub3" class="code" title="subfunction parse_char(inStr, c)">parse_char</a>(inStr, <span class="string">']'</span>);
0184                     <span class="keyword">return</span>;
0185             <span class="keyword">end</span>
0186             <span class="keyword">end</span>
0187 
0188             <span class="keyword">try</span>
0189               <span class="keyword">if</span>(~isempty(dim2))
0190             astr=arraystr;
0191             astr(astr==<span class="string">'['</span>)=<span class="string">''</span>;
0192             astr(astr==<span class="string">']'</span>)=<span class="string">''</span>;
0193                 astr=regexprep(astr,<span class="string">'\s*$'</span>,<span class="string">''</span>);
0194             astr(astr==<span class="string">' '</span>)=<span class="string">''</span>;
0195             [obj, count, errmsg, nextidx]=sscanf(astr,<span class="string">'%f,'</span>,inf);
0196             <span class="keyword">if</span>(nextidx&gt;=length(astr)-1)
0197                     object=reshape(obj,dim2,numel(obj)/dim2)';
0198                     pos=endpos;
0199                     <a href="#_sub3" class="code" title="subfunction parse_char(inStr, c)">parse_char</a>(inStr, <span class="string">']'</span>);
0200                     <span class="keyword">if</span>(pbar&gt;0)
0201                         waitbar(pos/length(inStr),pbar,<span class="string">'loading ...'</span>);
0202                     <span class="keyword">end</span>
0203                     <span class="keyword">return</span>;
0204             <span class="keyword">end</span>
0205               <span class="keyword">end</span>
0206               arraystr=regexprep(arraystr,<span class="string">'\]\s*,'</span>,<span class="string">'];'</span>);
0207             <span class="keyword">catch</span>
0208             <span class="keyword">end</span>
0209     <span class="keyword">else</span>
0210             arraystr=<span class="string">'['</span>;
0211     <span class="keyword">end</span>
0212         <span class="keyword">try</span>
0213            arraystr=regexprep(arraystr,<span class="string">'^\s*\['</span>,<span class="string">'{'</span>,<span class="string">'once'</span>);
0214            arraystr=regexprep(arraystr,<span class="string">'\]\s*$'</span>,<span class="string">'}'</span>,<span class="string">'once'</span>);
0215            <span class="keyword">if</span>(isoct &amp;&amp; regexp(arraystr,<span class="string">'&quot;'</span>,<span class="string">'once'</span>))
0216                 error(<span class="string">'Octave eval can produce empty cells for JSON-like input'</span>);
0217            <span class="keyword">end</span>
0218            object=eval(arraystr);
0219            pos=endpos;
0220         <span class="keyword">catch</span>
0221          <span class="keyword">while</span> 1
0222             newopt=<a href="varargin2struct.html" class="code" title="function opt=varargin2struct(varargin)">varargin2struct</a>(varargin{:},<span class="string">'JSONLAB_ArrayDepth_'</span>,arraydepth+1);
0223             val = <a href="#_sub8" class="code" title="subfunction val = parse_value(inStr, esc, varargin)">parse_value</a>(inStr, esc, newopt);
0224             object{end+1} = val;
0225             <span class="keyword">if</span> <a href="#_sub4" class="code" title="subfunction c = next_char(inStr)">next_char</a>(inStr) == <span class="string">']'</span>
0226                 <span class="keyword">break</span>;
0227             <span class="keyword">end</span>
0228             <a href="#_sub3" class="code" title="subfunction parse_char(inStr, c)">parse_char</a>(inStr, <span class="string">','</span>);
0229          <span class="keyword">end</span>
0230         <span class="keyword">end</span>
0231     <span class="keyword">end</span>
0232     <span class="keyword">if</span>(<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'SimplifyCell'</span>,0,varargin{:})==1)
0233       <span class="keyword">try</span>
0234         oldobj=object;
0235         object=cell2mat(object')';
0236         <span class="keyword">if</span>(iscell(oldobj) &amp;&amp; isstruct(object) &amp;&amp; numel(object)&gt;1 &amp;&amp; <a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'SimplifyCellArray'</span>,1,varargin{:})==0)
0237             object=oldobj;
0238         <span class="keyword">elseif</span>(size(object,1)&gt;1 &amp;&amp; ismatrix(object))
0239             object=object';
0240         <span class="keyword">end</span>
0241       <span class="keyword">catch</span>
0242       <span class="keyword">end</span>
0243     <span class="keyword">end</span>
0244     <a href="#_sub3" class="code" title="subfunction parse_char(inStr, c)">parse_char</a>(inStr, <span class="string">']'</span>);
0245     
0246     <span class="keyword">if</span>(pbar&gt;0)
0247         waitbar(pos/length(inStr),pbar,<span class="string">'loading ...'</span>);
0248     <span class="keyword">end</span>
0249 <span class="comment">%%-------------------------------------------------------------------------</span>
0250 
0251 <a name="_sub3" href="#_subfunctions" class="code">function parse_char(inStr, c)</a>
0252     <span class="keyword">global</span> pos
0253     pos=<a href="#_sub5" class="code" title="subfunction newpos=skip_whitespace(pos, inStr)">skip_whitespace</a>(pos, inStr);
0254     <span class="keyword">if</span> pos &gt; length(inStr) || inStr(pos) ~= c
0255         <a href="#_sub9" class="code" title="subfunction error_pos(msg, inStr)">error_pos</a>(sprintf(<span class="string">'Expected %c at position %%d'</span>, c),inStr);
0256     <span class="keyword">else</span>
0257         pos = pos + 1;
0258         pos=<a href="#_sub5" class="code" title="subfunction newpos=skip_whitespace(pos, inStr)">skip_whitespace</a>(pos, inStr);
0259     <span class="keyword">end</span>
0260 
0261 <span class="comment">%%-------------------------------------------------------------------------</span>
0262 
0263 <a name="_sub4" href="#_subfunctions" class="code">function c = next_char(inStr)</a>
0264     <span class="keyword">global</span> pos
0265     pos=<a href="#_sub5" class="code" title="subfunction newpos=skip_whitespace(pos, inStr)">skip_whitespace</a>(pos, inStr);
0266     <span class="keyword">if</span> pos &gt; length(inStr)
0267         c = [];
0268     <span class="keyword">else</span>
0269         c = inStr(pos);
0270     <span class="keyword">end</span>
0271 
0272 <span class="comment">%%-------------------------------------------------------------------------</span>
0273 
0274 <a name="_sub5" href="#_subfunctions" class="code">function newpos=skip_whitespace(pos, inStr)</a>
0275     newpos=pos;
0276     <span class="keyword">while</span> newpos &lt;= length(inStr) &amp;&amp; isspace(inStr(newpos))
0277         newpos = newpos + 1;
0278     <span class="keyword">end</span>
0279 
0280 <span class="comment">%%-------------------------------------------------------------------------</span>
0281 <a name="_sub6" href="#_subfunctions" class="code">function str = parseStr(inStr, esc, varargin)</a>
0282     <span class="keyword">global</span> pos index_esc
0283  <span class="comment">% len, ns = length(inStr), keyboard</span>
0284     <span class="keyword">if</span> inStr(pos) ~= <span class="string">'&quot;'</span>
0285         <a href="#_sub9" class="code" title="subfunction error_pos(msg, inStr)">error_pos</a>(<span class="string">'String starting with &quot; expected at position %d'</span>,inStr);
0286     <span class="keyword">else</span>
0287         pos = pos + 1;
0288     <span class="keyword">end</span>
0289     str = <span class="string">''</span>;
0290     <span class="keyword">while</span> pos &lt;= length(inStr)
0291         <span class="keyword">while</span> index_esc &lt;= length(esc) &amp;&amp; esc(index_esc) &lt; pos
0292             index_esc = index_esc + 1;
0293         <span class="keyword">end</span>
0294         <span class="keyword">if</span> index_esc &gt; length(esc)
0295             str = [str inStr(pos:end)];
0296             pos = length(inStr) + 1;
0297             <span class="keyword">break</span>;
0298         <span class="keyword">else</span>
0299             str = [str inStr(pos:esc(index_esc)-1)];
0300             pos = esc(index_esc);
0301         <span class="keyword">end</span>
0302         nstr = length(str);
0303         <span class="keyword">switch</span> inStr(pos)
0304             <span class="keyword">case</span> <span class="string">'&quot;'</span>
0305                 pos = pos + 1;
0306                 <span class="keyword">if</span>(~isempty(str))
0307                     <span class="keyword">if</span>(strcmp(str,<span class="string">'_Inf_'</span>))
0308                         str=Inf;
0309                     <span class="keyword">elseif</span>(strcmp(str,<span class="string">'-_Inf_'</span>))
0310                         str=-Inf;
0311                     <span class="keyword">elseif</span>(strcmp(str,<span class="string">'_NaN_'</span>))
0312                         str=NaN;
0313                     <span class="keyword">end</span>
0314                 <span class="keyword">end</span>
0315                 <span class="keyword">return</span>;
0316             <span class="keyword">case</span> <span class="string">'\'</span>
0317                 <span class="keyword">if</span> pos+1 &gt; length(inStr)
0318                     <a href="#_sub9" class="code" title="subfunction error_pos(msg, inStr)">error_pos</a>(<span class="string">'End of file reached right after escape character'</span>,inStr);
0319                 <span class="keyword">end</span>
0320                 pos = pos + 1;
0321                 <span class="keyword">switch</span> inStr(pos)
0322                     <span class="keyword">case</span> {<span class="string">'&quot;'</span> <span class="string">'\'</span> <span class="string">'/'</span>}
0323                         str(nstr+1) = inStr(pos);
0324                         pos = pos + 1;
0325                     <span class="keyword">case</span> {<span class="string">'b'</span> <span class="string">'f'</span> <span class="string">'n'</span> <span class="string">'r'</span> <span class="string">'t'</span>}
0326                         str(nstr+1) = sprintf([<span class="string">'\'</span> inStr(pos)]);
0327                         pos = pos + 1;
0328                     <span class="keyword">case</span> <span class="string">'u'</span>
0329                         <span class="keyword">if</span> pos+4 &gt; length(inStr)
0330                             <a href="#_sub9" class="code" title="subfunction error_pos(msg, inStr)">error_pos</a>(<span class="string">'End of file reached in escaped unicode character'</span>,inStr);
0331                         <span class="keyword">end</span>
0332                         str(nstr+(1:6)) = inStr(pos-1:pos+4);
0333                         pos = pos + 5;
0334                 <span class="keyword">end</span>
0335             <span class="keyword">otherwise</span> <span class="comment">% should never happen</span>
0336                 str(nstr+1) = inStr(pos);
0337                 keyboard;
0338                 pos = pos + 1;
0339         <span class="keyword">end</span>
0340     <span class="keyword">end</span>
0341     <a href="#_sub9" class="code" title="subfunction error_pos(msg, inStr)">error_pos</a>(<span class="string">'End of file while expecting end of inStr'</span>,inStr);
0342 
0343 <span class="comment">%%-------------------------------------------------------------------------</span>
0344 
0345 <a name="_sub7" href="#_subfunctions" class="code">function num = parse_number(inStr, varargin)</a>
0346     <span class="keyword">global</span> pos isoct
0347     currstr=inStr(pos:min(pos+30,end));
0348     <span class="keyword">if</span>(isoct~=0)
0349         numstr=regexp(currstr,<span class="string">'^\s*-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+\-]?\d+)?'</span>,<span class="string">'end'</span>);
0350         [num] = sscanf(currstr, <span class="string">'%f'</span>, 1);
0351         delta=numstr+1;
0352     <span class="keyword">else</span>
0353         [num, one, err, delta] = sscanf(currstr, <span class="string">'%f'</span>, 1);
0354         <span class="keyword">if</span> ~isempty(err)
0355             <a href="#_sub9" class="code" title="subfunction error_pos(msg, inStr)">error_pos</a>(<span class="string">'Error reading number at position %d'</span>,inStr);
0356         <span class="keyword">end</span>
0357     <span class="keyword">end</span>
0358     pos = pos + delta-1;
0359 
0360 <span class="comment">%%-------------------------------------------------------------------------</span>
0361 
0362 <a name="_sub8" href="#_subfunctions" class="code">function val = parse_value(inStr, esc, varargin)</a>
0363     <span class="keyword">global</span> pos
0364     len=length(inStr);
0365     <span class="keyword">if</span>(isfield(varargin{1},<span class="string">'progressbar_'</span>))
0366         waitbar(pos/len,varargin{1}.progressbar_,<span class="string">'loading ...'</span>);
0367     <span class="keyword">end</span>
0368     
0369     <span class="keyword">switch</span>(inStr(pos))
0370         <span class="keyword">case</span> <span class="string">'&quot;'</span>
0371             val = <a href="#_sub6" class="code" title="subfunction str = parseStr(inStr, esc, varargin)">parseStr</a>(inStr, esc, varargin{:});
0372             <span class="keyword">return</span>;
0373         <span class="keyword">case</span> <span class="string">'['</span>
0374             val = <a href="#_sub2" class="code" title="subfunction object = parse_array(inStr, esc, varargin) ">parse_array</a>(inStr, esc, varargin{:});
0375             <span class="keyword">return</span>;
0376         <span class="keyword">case</span> <span class="string">'{'</span>
0377             val = <a href="#_sub1" class="code" title="subfunction object = parse_object(inStr, esc, varargin)">parse_object</a>(inStr, esc, varargin{:});
0378             <span class="keyword">return</span>;
0379         <span class="keyword">case</span> {<span class="string">'-'</span>,<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>}
0380             val = <a href="#_sub7" class="code" title="subfunction num = parse_number(inStr, varargin)">parse_number</a>(inStr, varargin{:});
0381             <span class="keyword">return</span>;
0382         <span class="keyword">case</span> <span class="string">'t'</span>
0383             <span class="keyword">if</span> pos+3 &lt;= len &amp;&amp; strcmpi(inStr(pos:pos+3), <span class="string">'true'</span>)
0384                 val = true;
0385                 pos = pos + 4;
0386                 <span class="keyword">return</span>;
0387             <span class="keyword">end</span>
0388         <span class="keyword">case</span> <span class="string">'f'</span>
0389             <span class="keyword">if</span> pos+4 &lt;= len &amp;&amp; strcmpi(inStr(pos:pos+4), <span class="string">'false'</span>)
0390                 val = false;
0391                 pos = pos + 5;
0392                 <span class="keyword">return</span>;
0393             <span class="keyword">end</span>
0394         <span class="keyword">case</span> <span class="string">'n'</span>
0395             <span class="keyword">if</span> pos+3 &lt;= len &amp;&amp; strcmpi(inStr(pos:pos+3), <span class="string">'null'</span>)
0396                 val = [];
0397                 pos = pos + 4;
0398                 <span class="keyword">return</span>;
0399             <span class="keyword">end</span>
0400     <span class="keyword">end</span>
0401     <a href="#_sub9" class="code" title="subfunction error_pos(msg, inStr)">error_pos</a>(<span class="string">'Value expected at position %d'</span>,inStr);
0402 <span class="comment">%%-------------------------------------------------------------------------</span>
0403 
0404 <a name="_sub9" href="#_subfunctions" class="code">function error_pos(msg, inStr)</a>
0405     <span class="keyword">global</span> pos len
0406     poShow = max(min([pos-15 pos-1 pos pos+20],len),1);
0407     <span class="keyword">if</span> poShow(3) == poShow(2)
0408         poShow(3:4) = poShow(2)+[0 -1];  <span class="comment">% display nothing after</span>
0409     <span class="keyword">end</span>
0410     msg = [sprintf(msg, pos) <span class="string">': '</span> <span class="keyword">...</span>
0411     inStr(poShow(1):poShow(2)) <span class="string">'&lt;error&gt;'</span> inStr(poShow(3):poShow(4)) ];
0412     error( [<span class="string">'JSONparser:invalidFormat: '</span> msg] );
0413 
0414 <span class="comment">%%-------------------------------------------------------------------------</span>
0415 
0416 <a name="_sub10" href="#_subfunctions" class="code">function str = valid_field(str)</a>
0417 <span class="keyword">global</span> isoct
0418 <span class="comment">% From MATLAB doc: field names must begin with a letter, which may be</span>
0419 <span class="comment">% followed by any combination of letters, digits, and underscores.</span>
0420 <span class="comment">% Invalid characters will be converted to underscores, and the prefix</span>
0421 <span class="comment">% &quot;x0x[Hex code]_&quot; will be added if the first character is not a letter.</span>
0422     pos=regexp(str,<span class="string">'^[^A-Za-z]'</span>,<span class="string">'once'</span>);
0423     <span class="keyword">if</span>(~isempty(pos))
0424         <span class="keyword">if</span>(~isoct &amp;&amp; str(1)+0 &gt; 255)
0425             str=regexprep(str,<span class="string">'^([^A-Za-z])'</span>,<span class="string">'x0x${sprintf(''%X'',unicode2native($1))}_'</span>,<span class="string">'once'</span>);
0426         <span class="keyword">else</span>
0427             str=sprintf(<span class="string">'x0x%X_%s'</span>,char(str(1)),str(2:end));
0428         <span class="keyword">end</span>
0429     <span class="keyword">end</span>
0430     <span class="keyword">if</span>(isempty(regexp(str,<span class="string">'[^0-9A-Za-z_]'</span>, <span class="string">'once'</span> )))
0431         <span class="keyword">return</span>;
0432     <span class="keyword">end</span>
0433     <span class="keyword">if</span>(~isoct)
0434         str=regexprep(str,<span class="string">'([^0-9A-Za-z_])'</span>,<span class="string">'_0x${sprintf(''%X'',unicode2native($1))}_'</span>);
0435     <span class="keyword">else</span>
0436         pos=regexp(str,<span class="string">'[^0-9A-Za-z_]'</span>);
0437         <span class="keyword">if</span>(isempty(pos))
0438             <span class="keyword">return</span>;
0439         <span class="keyword">end</span>
0440         str0=str;
0441         pos0=[0 pos(:)' length(str)];
0442         str=<span class="string">''</span>;
0443         <span class="keyword">for</span> i=1:length(pos)
0444             str=[str str0(pos0(i)+1:pos(i)-1) sprintf(<span class="string">'_0x%X_'</span>,str0(pos(i)))];
0445         <span class="keyword">end</span>
0446         <span class="keyword">if</span>(pos(end)~=length(str))
0447             str=[str str0(pos0(end-1)+1:pos0(end))];
0448         <span class="keyword">end</span>
0449     <span class="keyword">end</span>
0450     <span class="comment">%str(~isletter(str) &amp; ~('0' &lt;= str &amp; str &lt;= '9')) = '_';</span>
0451 
0452 <span class="comment">%%-------------------------------------------------------------------------</span>
0453 <a name="_sub11" href="#_subfunctions" class="code">function endpos = matching_quote(str,pos)</a>
0454 len=length(str);
0455 <span class="keyword">while</span>(pos&lt;len)
0456     <span class="keyword">if</span>(str(pos)==<span class="string">'&quot;'</span>)
0457         <span class="keyword">if</span>(~(pos&gt;1 &amp;&amp; str(pos-1)==<span class="string">'\'</span>))
0458             endpos=pos;
0459             <span class="keyword">return</span>;
0460         <span class="keyword">end</span>        
0461     <span class="keyword">end</span>
0462     pos=pos+1;
0463 <span class="keyword">end</span>
0464 error(<span class="string">'unmatched quotation mark'</span>);
0465 <span class="comment">%%-------------------------------------------------------------------------</span>
0466 <a name="_sub12" href="#_subfunctions" class="code">function [endpos, e1l, e1r, maxlevel] = matching_bracket(str,pos)</a>
0467 <span class="keyword">global</span> arraytoken
0468 level=1;
0469 maxlevel=level;
0470 endpos=0;
0471 bpos=arraytoken(arraytoken&gt;=pos);
0472 tokens=str(bpos);
0473 len=length(tokens);
0474 pos=1;
0475 e1l=[];
0476 e1r=[];
0477 <span class="keyword">while</span>(pos&lt;=len)
0478     c=tokens(pos);
0479     <span class="keyword">if</span>(c==<span class="string">']'</span>)
0480         level=level-1;
0481         <span class="keyword">if</span>(isempty(e1r))
0482             e1r=bpos(pos);
0483         <span class="keyword">end</span>
0484         <span class="keyword">if</span>(level==0)
0485             endpos=bpos(pos);
0486             <span class="keyword">return</span>
0487         <span class="keyword">end</span>
0488     <span class="keyword">end</span>
0489     <span class="keyword">if</span>(c==<span class="string">'['</span>)
0490         <span class="keyword">if</span>(isempty(e1l))
0491             e1l=bpos(pos);
0492         <span class="keyword">end</span>
0493         level=level+1;
0494         maxlevel=max(maxlevel,level);
0495     <span class="keyword">end</span>
0496     <span class="keyword">if</span>(c==<span class="string">'&quot;'</span>)
0497         pos=<a href="#_sub11" class="code" title="subfunction endpos = matching_quote(str,pos)">matching_quote</a>(tokens,pos+1);
0498     <span class="keyword">end</span>
0499     pos=pos+1;
0500 <span class="keyword">end</span>
0501 <span class="keyword">if</span>(endpos==0) 
0502     error(<span class="string">'unmatched &quot;]&quot;'</span>);
0503 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 17-Nov-2017 17:25:01 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>