<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of savejson</title>
  <meta name="keywords" content="savejson">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../index.html">Home</a> &gt;  <a href="#">Scripts</a> &gt; <a href="#">external</a> &gt; <a href="#">jsonlab-1.5</a> &gt; <a href="index.html">jsonlab-1.5</a> &gt; savejson.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../index.html"><img alt="<" border="0" src="../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for Scripts/external/jsonlab-1.5/jsonlab-1.5&nbsp;<img alt=">" border="0" src="../../../../right.png"></a></td></tr></table>-->

<h1>savejson
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function json=savejson(rootname,obj,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">
 json=savejson(rootname,obj,filename)
    or
 json=savejson(rootname,obj,opt)
 json=savejson(rootname,obj,'param1',value1,'param2',value2,...)

 convert a MATLAB object (cell, struct or array) into a JSON (JavaScript
 Object Notation) string

 author: Qianqian Fang (q.fang &lt;at&gt; neu.edu)
 created on 2011/09/09

 $Id$

 input:
      rootname: the name of the root-object, when set to '', the root name
        is ignored, however, when opt.ForceRootName is set to 1 (see below),
        the MATLAB variable name will be used as the root name.
      obj: a MATLAB object (array, cell, cell array, struct, struct array,
      class instance).
      filename: a string for the file name to save the output JSON data.
      opt: a struct for additional options, ignore to use default values.
        opt can have the following fields (first in [.|.] is the default)

        opt.FileName [''|string]: a file name to save the output JSON data
        opt.FloatFormat ['%.10g'|string]: format to show each numeric element
                         of a 1D/2D array;
        opt.ArrayIndent [1|0]: if 1, output explicit data array with
                         precedent indentation; if 0, no indentation
        opt.ArrayToStruct[0|1]: when set to 0, savejson outputs 1D/2D
                         array in JSON array format; if sets to 1, an
                         array will be shown as a struct with fields
                         &quot;_ArrayType_&quot;, &quot;_ArraySize_&quot; and &quot;_ArrayData_&quot;; for
                         sparse arrays, the non-zero elements will be
                         saved to _ArrayData_ field in triplet-format i.e.
                         (ix,iy,val) and &quot;_ArrayIsSparse_&quot; will be added
                         with a value of 1; for a complex array, the 
                         _ArrayData_ array will include two columns 
                         (4 for sparse) to record the real and imaginary 
                         parts, and also &quot;_ArrayIsComplex_&quot;:1 is added. 
        opt.ParseLogical [0|1]: if this is set to 1, logical array elem
                         will use true/false rather than 1/0.
        opt.SingletArray [0|1]: if this is set to 1, arrays with a single
                         numerical element will be shown without a square
                         bracket, unless it is the root object; if 0, square
                         brackets are forced for any numerical arrays.
        opt.SingletCell  [1|0]: if 1, always enclose a cell with &quot;[]&quot; 
                         even it has only one element; if 0, brackets
                         are ignored when a cell has only 1 element.
        opt.ForceRootName [0|1]: when set to 1 and rootname is empty, savejson
                         will use the name of the passed obj variable as the 
                         root object name; if obj is an expression and 
                         does not have a name, 'root' will be used; if this 
                         is set to 0 and rootname is empty, the root level 
                         will be merged down to the lower level.
        opt.Inf ['&quot;$1_Inf_&quot;'|string]: a customized regular expression pattern
                         to represent +/-Inf. The matched pattern is '([-+]*)Inf'
                         and $1 represents the sign. For those who want to use
                         1e999 to represent Inf, they can set opt.Inf to '$11e999'
        opt.NaN ['&quot;_NaN_&quot;'|string]: a customized regular expression pattern
                         to represent NaN
        opt.JSONP [''|string]: to generate a JSONP output (JSON with padding),
                         for example, if opt.JSONP='foo', the JSON data is
                         wrapped inside a function call as 'foo(...);'
        opt.UnpackHex [1|0]: conver the 0x[hex code] output by loadjson 
                         back to the string form
        opt.SaveBinary [0|1]: 1 - save the JSON file in binary mode; 0 - text mode.
        opt.Compact [0|1]: 1- out compact JSON format (remove all newlines and tabs)

        opt can be replaced by a list of ('param',value) pairs. The param 
        string is equivallent to a field in opt and is case sensitive.
 output:
      json: a string in the JSON format (see http://json.org)

 examples:
      jsonmesh=struct('MeshNode',[0 0 0;1 0 0;0 1 0;1 1 0;0 0 1;1 0 1;0 1 1;1 1 1],... 
               'MeshTetra',[1 2 4 8;1 3 4 8;1 2 6 8;1 5 6 8;1 5 7 8;1 3 7 8],...
               'MeshTri',[1 2 4;1 2 6;1 3 4;1 3 7;1 5 6;1 5 7;...
                          2 8 4;2 8 6;3 8 4;3 8 7;5 8 6;5 8 7],...
               'MeshCreator','FangQ','MeshTitle','T6 Cube',...
               'SpecialData',[nan, inf, -inf]);
      savejson('jmesh',jsonmesh)
      savejson('',jsonmesh,'ArrayIndent',0,'FloatFormat','\t%.5g')

 license:
     BSD License, see LICENSE_BSD.txt files for details

 -- this function is part of JSONLab toolbox (http://iso2mesh.sf.net/cgi-bin/index.cgi?jsonlab)</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>	</li><li><a href="varargin2struct.html" class="code" title="function opt=varargin2struct(varargin)">varargin2struct</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function txt=obj2json(name,item,level,varargin)</a></li><li><a href="#_sub2" class="code">function txt=cell2json(name,item,level,varargin)</a></li><li><a href="#_sub3" class="code">function txt=struct2json(name,item,level,varargin)</a></li><li><a href="#_sub4" class="code">function txt=str2json(name,item,level,varargin)</a></li><li><a href="#_sub5" class="code">function txt=mat2json(name,item,level,varargin)</a></li><li><a href="#_sub6" class="code">function txt=matlabobject2json(name,item,level,varargin)</a></li><li><a href="#_sub7" class="code">function txt=matdata2json(mat,level,varargin)</a></li><li><a href="#_sub8" class="code">function newname=checkname(name,varargin)</a></li><li><a href="#_sub9" class="code">function newstr=escapejsonstring(str)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function json=savejson(rootname,obj,varargin)</a>
0002 <span class="comment">%</span>
0003 <span class="comment">% json=savejson(rootname,obj,filename)</span>
0004 <span class="comment">%    or</span>
0005 <span class="comment">% json=savejson(rootname,obj,opt)</span>
0006 <span class="comment">% json=savejson(rootname,obj,'param1',value1,'param2',value2,...)</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% convert a MATLAB object (cell, struct or array) into a JSON (JavaScript</span>
0009 <span class="comment">% Object Notation) string</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% author: Qianqian Fang (q.fang &lt;at&gt; neu.edu)</span>
0012 <span class="comment">% created on 2011/09/09</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% $Id$</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% input:</span>
0017 <span class="comment">%      rootname: the name of the root-object, when set to '', the root name</span>
0018 <span class="comment">%        is ignored, however, when opt.ForceRootName is set to 1 (see below),</span>
0019 <span class="comment">%        the MATLAB variable name will be used as the root name.</span>
0020 <span class="comment">%      obj: a MATLAB object (array, cell, cell array, struct, struct array,</span>
0021 <span class="comment">%      class instance).</span>
0022 <span class="comment">%      filename: a string for the file name to save the output JSON data.</span>
0023 <span class="comment">%      opt: a struct for additional options, ignore to use default values.</span>
0024 <span class="comment">%        opt can have the following fields (first in [.|.] is the default)</span>
0025 <span class="comment">%</span>
0026 <span class="comment">%        opt.FileName [''|string]: a file name to save the output JSON data</span>
0027 <span class="comment">%        opt.FloatFormat ['%.10g'|string]: format to show each numeric element</span>
0028 <span class="comment">%                         of a 1D/2D array;</span>
0029 <span class="comment">%        opt.ArrayIndent [1|0]: if 1, output explicit data array with</span>
0030 <span class="comment">%                         precedent indentation; if 0, no indentation</span>
0031 <span class="comment">%        opt.ArrayToStruct[0|1]: when set to 0, savejson outputs 1D/2D</span>
0032 <span class="comment">%                         array in JSON array format; if sets to 1, an</span>
0033 <span class="comment">%                         array will be shown as a struct with fields</span>
0034 <span class="comment">%                         &quot;_ArrayType_&quot;, &quot;_ArraySize_&quot; and &quot;_ArrayData_&quot;; for</span>
0035 <span class="comment">%                         sparse arrays, the non-zero elements will be</span>
0036 <span class="comment">%                         saved to _ArrayData_ field in triplet-format i.e.</span>
0037 <span class="comment">%                         (ix,iy,val) and &quot;_ArrayIsSparse_&quot; will be added</span>
0038 <span class="comment">%                         with a value of 1; for a complex array, the</span>
0039 <span class="comment">%                         _ArrayData_ array will include two columns</span>
0040 <span class="comment">%                         (4 for sparse) to record the real and imaginary</span>
0041 <span class="comment">%                         parts, and also &quot;_ArrayIsComplex_&quot;:1 is added.</span>
0042 <span class="comment">%        opt.ParseLogical [0|1]: if this is set to 1, logical array elem</span>
0043 <span class="comment">%                         will use true/false rather than 1/0.</span>
0044 <span class="comment">%        opt.SingletArray [0|1]: if this is set to 1, arrays with a single</span>
0045 <span class="comment">%                         numerical element will be shown without a square</span>
0046 <span class="comment">%                         bracket, unless it is the root object; if 0, square</span>
0047 <span class="comment">%                         brackets are forced for any numerical arrays.</span>
0048 <span class="comment">%        opt.SingletCell  [1|0]: if 1, always enclose a cell with &quot;[]&quot;</span>
0049 <span class="comment">%                         even it has only one element; if 0, brackets</span>
0050 <span class="comment">%                         are ignored when a cell has only 1 element.</span>
0051 <span class="comment">%        opt.ForceRootName [0|1]: when set to 1 and rootname is empty, savejson</span>
0052 <span class="comment">%                         will use the name of the passed obj variable as the</span>
0053 <span class="comment">%                         root object name; if obj is an expression and</span>
0054 <span class="comment">%                         does not have a name, 'root' will be used; if this</span>
0055 <span class="comment">%                         is set to 0 and rootname is empty, the root level</span>
0056 <span class="comment">%                         will be merged down to the lower level.</span>
0057 <span class="comment">%        opt.Inf ['&quot;$1_Inf_&quot;'|string]: a customized regular expression pattern</span>
0058 <span class="comment">%                         to represent +/-Inf. The matched pattern is '([-+]*)Inf'</span>
0059 <span class="comment">%                         and $1 represents the sign. For those who want to use</span>
0060 <span class="comment">%                         1e999 to represent Inf, they can set opt.Inf to '$11e999'</span>
0061 <span class="comment">%        opt.NaN ['&quot;_NaN_&quot;'|string]: a customized regular expression pattern</span>
0062 <span class="comment">%                         to represent NaN</span>
0063 <span class="comment">%        opt.JSONP [''|string]: to generate a JSONP output (JSON with padding),</span>
0064 <span class="comment">%                         for example, if opt.JSONP='foo', the JSON data is</span>
0065 <span class="comment">%                         wrapped inside a function call as 'foo(...);'</span>
0066 <span class="comment">%        opt.UnpackHex [1|0]: conver the 0x[hex code] output by loadjson</span>
0067 <span class="comment">%                         back to the string form</span>
0068 <span class="comment">%        opt.SaveBinary [0|1]: 1 - save the JSON file in binary mode; 0 - text mode.</span>
0069 <span class="comment">%        opt.Compact [0|1]: 1- out compact JSON format (remove all newlines and tabs)</span>
0070 <span class="comment">%</span>
0071 <span class="comment">%        opt can be replaced by a list of ('param',value) pairs. The param</span>
0072 <span class="comment">%        string is equivallent to a field in opt and is case sensitive.</span>
0073 <span class="comment">% output:</span>
0074 <span class="comment">%      json: a string in the JSON format (see http://json.org)</span>
0075 <span class="comment">%</span>
0076 <span class="comment">% examples:</span>
0077 <span class="comment">%      jsonmesh=struct('MeshNode',[0 0 0;1 0 0;0 1 0;1 1 0;0 0 1;1 0 1;0 1 1;1 1 1],...</span>
0078 <span class="comment">%               'MeshTetra',[1 2 4 8;1 3 4 8;1 2 6 8;1 5 6 8;1 5 7 8;1 3 7 8],...</span>
0079 <span class="comment">%               'MeshTri',[1 2 4;1 2 6;1 3 4;1 3 7;1 5 6;1 5 7;...</span>
0080 <span class="comment">%                          2 8 4;2 8 6;3 8 4;3 8 7;5 8 6;5 8 7],...</span>
0081 <span class="comment">%               'MeshCreator','FangQ','MeshTitle','T6 Cube',...</span>
0082 <span class="comment">%               'SpecialData',[nan, inf, -inf]);</span>
0083 <span class="comment">%      savejson('jmesh',jsonmesh)</span>
0084 <span class="comment">%      savejson('',jsonmesh,'ArrayIndent',0,'FloatFormat','\t%.5g')</span>
0085 <span class="comment">%</span>
0086 <span class="comment">% license:</span>
0087 <span class="comment">%     BSD License, see LICENSE_BSD.txt files for details</span>
0088 <span class="comment">%</span>
0089 <span class="comment">% -- this function is part of JSONLab toolbox (http://iso2mesh.sf.net/cgi-bin/index.cgi?jsonlab)</span>
0090 <span class="comment">%</span>
0091 
0092 <span class="keyword">if</span>(nargin==1)
0093    varname=inputname(1);
0094    obj=rootname;
0095    <span class="keyword">if</span>(isempty(varname)) 
0096       varname=<span class="string">'root'</span>;
0097    <span class="keyword">end</span>
0098    rootname=varname;
0099 <span class="keyword">else</span>
0100    varname=inputname(2);
0101 <span class="keyword">end</span>
0102 <span class="keyword">if</span>(length(varargin)==1 &amp;&amp; ischar(varargin{1}))
0103    opt=struct(<span class="string">'filename'</span>,varargin{1});
0104 <span class="keyword">else</span>
0105    opt=<a href="varargin2struct.html" class="code" title="function opt=varargin2struct(varargin)">varargin2struct</a>(varargin{:});
0106 <span class="keyword">end</span>
0107 opt.IsOctave=exist(<span class="string">'OCTAVE_VERSION'</span>,<span class="string">'builtin'</span>);
0108 <span class="keyword">if</span>(isfield(opt,<span class="string">'norowbracket'</span>))
0109     warning(<span class="string">'Option ''NoRowBracket'' is depreciated, please use ''SingletArray'' and set its value to not(NoRowBracket)'</span>);
0110     <span class="keyword">if</span>(~isfield(opt,<span class="string">'singletarray'</span>))
0111         opt.singletarray=not(opt.norowbracket);
0112     <span class="keyword">end</span>
0113 <span class="keyword">end</span>
0114 rootisarray=0;
0115 rootlevel=1;
0116 forceroot=<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'ForceRootName'</span>,0,opt);
0117 <span class="keyword">if</span>((isnumeric(obj) || islogical(obj) || ischar(obj) || isstruct(obj) || <span class="keyword">...</span>
0118         iscell(obj) || isobject(obj)) &amp;&amp; isempty(rootname) &amp;&amp; forceroot==0)
0119     rootisarray=1;
0120     rootlevel=0;
0121 <span class="keyword">else</span>
0122     <span class="keyword">if</span>(isempty(rootname))
0123         rootname=varname;
0124     <span class="keyword">end</span>
0125 <span class="keyword">end</span>
0126 <span class="keyword">if</span>((isstruct(obj) || iscell(obj))&amp;&amp; isempty(rootname) &amp;&amp; forceroot)
0127     rootname=<span class="string">'root'</span>;
0128 <span class="keyword">end</span>
0129 
0130 whitespaces=struct(<span class="string">'tab'</span>,sprintf(<span class="string">'\t'</span>),<span class="string">'newline'</span>,sprintf(<span class="string">'\n'</span>),<span class="string">'sep'</span>,sprintf(<span class="string">',\n'</span>));
0131 <span class="keyword">if</span>(<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'Compact'</span>,0,opt)==1)
0132     whitespaces=struct(<span class="string">'tab'</span>,<span class="string">''</span>,<span class="string">'newline'</span>,<span class="string">''</span>,<span class="string">'sep'</span>,<span class="string">','</span>);
0133 <span class="keyword">end</span>
0134 <span class="keyword">if</span>(~isfield(opt,<span class="string">'whitespaces_'</span>))
0135     opt.whitespaces_=whitespaces;
0136 <span class="keyword">end</span>
0137 
0138 nl=whitespaces.newline;
0139 
0140 json=<a href="#_sub1" class="code" title="subfunction txt=obj2json(name,item,level,varargin)">obj2json</a>(rootname,obj,rootlevel,opt);
0141 <span class="keyword">if</span>(rootisarray)
0142     json=sprintf(<span class="string">'%s%s'</span>,json,nl);
0143 <span class="keyword">else</span>
0144     json=sprintf(<span class="string">'{%s%s%s}\n'</span>,nl,json,nl);
0145 <span class="keyword">end</span>
0146 
0147 jsonp=<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'JSONP'</span>,<span class="string">''</span>,opt);
0148 <span class="keyword">if</span>(~isempty(jsonp))
0149     json=sprintf(<span class="string">'%s(%s);%s'</span>,jsonp,json,nl);
0150 <span class="keyword">end</span>
0151 
0152 <span class="comment">% save to a file if FileName is set, suggested by Patrick Rapin</span>
0153 filename=<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'FileName'</span>,<span class="string">''</span>,opt);
0154 <span class="keyword">if</span>(~isempty(filename))
0155     <span class="keyword">if</span>(<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'SaveBinary'</span>,0,opt)==1)
0156         fid = fopen(filename, <span class="string">'wb'</span>);
0157         fwrite(fid,json);
0158     <span class="keyword">else</span>
0159         fid = fopen(filename, <span class="string">'wt'</span>);
0160         fwrite(fid,json,<span class="string">'char'</span>);
0161     <span class="keyword">end</span>
0162     fclose(fid);
0163 <span class="keyword">end</span>
0164 
0165 <span class="comment">%%-------------------------------------------------------------------------</span>
0166 <a name="_sub1" href="#_subfunctions" class="code">function txt=obj2json(name,item,level,varargin)</a>
0167 
0168 <span class="keyword">if</span>(iscell(item))
0169     txt=<a href="#_sub2" class="code" title="subfunction txt=cell2json(name,item,level,varargin)">cell2json</a>(name,item,level,varargin{:});
0170 <span class="keyword">elseif</span>(isstruct(item))
0171     txt=<a href="#_sub3" class="code" title="subfunction txt=struct2json(name,item,level,varargin)">struct2json</a>(name,item,level,varargin{:});
0172 <span class="keyword">elseif</span>(ischar(item))
0173     txt=<a href="#_sub4" class="code" title="subfunction txt=str2json(name,item,level,varargin)">str2json</a>(name,item,level,varargin{:});
0174 <span class="keyword">elseif</span>(isobject(item)) 
0175     txt=<a href="#_sub6" class="code" title="subfunction txt=matlabobject2json(name,item,level,varargin)">matlabobject2json</a>(name,item,level,varargin{:});
0176 <span class="keyword">else</span>
0177     txt=<a href="#_sub5" class="code" title="subfunction txt=mat2json(name,item,level,varargin)">mat2json</a>(name,item,level,varargin{:});
0178 <span class="keyword">end</span>
0179 
0180 <span class="comment">%%-------------------------------------------------------------------------</span>
0181 <a name="_sub2" href="#_subfunctions" class="code">function txt=cell2json(name,item,level,varargin)</a>
0182 txt={};
0183 <span class="keyword">if</span>(~iscell(item))
0184         error(<span class="string">'input is not a cell'</span>);
0185 <span class="keyword">end</span>
0186 
0187 dim=size(item);
0188 <span class="keyword">if</span>(ndims(squeeze(item))&gt;2) <span class="comment">% for 3D or higher dimensions, flatten to 2D for now</span>
0189     item=reshape(item,dim(1),numel(item)/dim(1));
0190     dim=size(item);
0191 <span class="keyword">end</span>
0192 len=numel(item);
0193 ws=<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'whitespaces_'</span>,struct(<span class="string">'tab'</span>,sprintf(<span class="string">'\t'</span>),<span class="string">'newline'</span>,sprintf(<span class="string">'\n'</span>),<span class="string">'sep'</span>,sprintf(<span class="string">',\n'</span>)),varargin{:});
0194 padding0=repmat(ws.tab,1,level);
0195 padding2=repmat(ws.tab,1,level+1);
0196 nl=ws.newline;
0197 bracketlevel=~<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'singletcell'</span>,1,varargin{:});
0198 <span class="keyword">if</span>(len&gt;bracketlevel)
0199     <span class="keyword">if</span>(~isempty(name))
0200         txt={padding0, <span class="string">'&quot;'</span>, <a href="#_sub8" class="code" title="subfunction newname=checkname(name,varargin)">checkname</a>(name,varargin{:}),<span class="string">'&quot;: ['</span>, nl}; name=<span class="string">''</span>; 
0201     <span class="keyword">else</span>
0202         txt={padding0, <span class="string">'['</span>, nl};
0203     <span class="keyword">end</span>
0204 <span class="keyword">elseif</span>(len==0)
0205     <span class="keyword">if</span>(~isempty(name))
0206         txt={padding0, <span class="string">'&quot;'</span> <a href="#_sub8" class="code" title="subfunction newname=checkname(name,varargin)">checkname</a>(name,varargin{:}) <span class="string">'&quot;: []'</span>}; name=<span class="string">''</span>; 
0207     <span class="keyword">else</span>
0208         txt={padding0, <span class="string">'[]'</span>};
0209     <span class="keyword">end</span>
0210 <span class="keyword">end</span>
0211 <span class="keyword">for</span> i=1:dim(1)
0212     <span class="keyword">if</span>(dim(1)&gt;1)
0213         txt(end+1:end+3)={padding2,<span class="string">'['</span>,nl};
0214     <span class="keyword">end</span>
0215     <span class="keyword">for</span> j=1:dim(2)
0216        txt{end+1}=<a href="#_sub1" class="code" title="subfunction txt=obj2json(name,item,level,varargin)">obj2json</a>(name,item{i,j},level+(dim(1)&gt;1)+(len&gt;bracketlevel),varargin{:});
0217        <span class="keyword">if</span>(j&lt;dim(2))
0218            txt(end+1:end+2)={<span class="string">','</span> nl};
0219        <span class="keyword">end</span>
0220     <span class="keyword">end</span>
0221     <span class="keyword">if</span>(dim(1)&gt;1)
0222         txt(end+1:end+3)={nl,padding2,<span class="string">']'</span>};
0223     <span class="keyword">end</span>
0224     <span class="keyword">if</span>(i&lt;dim(1))
0225         txt(end+1:end+2)={<span class="string">','</span> nl};
0226     <span class="keyword">end</span>
0227     <span class="comment">%if(j==dim(2)) txt=sprintf('%s%s',txt,sprintf(',%s',nl)); end</span>
0228 <span class="keyword">end</span>
0229 <span class="keyword">if</span>(len&gt;bracketlevel)
0230     txt(end+1:end+3)={nl,padding0,<span class="string">']'</span>};
0231 <span class="keyword">end</span>
0232 txt = sprintf(<span class="string">'%s'</span>,txt{:});
0233 
0234 <span class="comment">%%-------------------------------------------------------------------------</span>
0235 <a name="_sub3" href="#_subfunctions" class="code">function txt=struct2json(name,item,level,varargin)</a>
0236 txt={};
0237 <span class="keyword">if</span>(~isstruct(item))
0238     error(<span class="string">'input is not a struct'</span>);
0239 <span class="keyword">end</span>
0240 dim=size(item);
0241 <span class="keyword">if</span>(ndims(squeeze(item))&gt;2) <span class="comment">% for 3D or higher dimensions, flatten to 2D for now</span>
0242     item=reshape(item,dim(1),numel(item)/dim(1));
0243     dim=size(item);
0244 <span class="keyword">end</span>
0245 len=numel(item);
0246 forcearray= (len&gt;1 || (<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'SingletArray'</span>,0,varargin{:})==1 &amp;&amp; level&gt;0));
0247 ws=struct(<span class="string">'tab'</span>,sprintf(<span class="string">'\t'</span>),<span class="string">'newline'</span>,sprintf(<span class="string">'\n'</span>));
0248 ws=<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'whitespaces_'</span>,ws,varargin{:});
0249 padding0=repmat(ws.tab,1,level);
0250 padding2=repmat(ws.tab,1,level+1);
0251 padding1=repmat(ws.tab,1,level+(dim(1)&gt;1)+forcearray);
0252 nl=ws.newline;
0253 
0254 <span class="keyword">if</span>(isempty(item)) 
0255     <span class="keyword">if</span>(~isempty(name)) 
0256         txt={padding0, <span class="string">'&quot;'</span>, <a href="#_sub8" class="code" title="subfunction newname=checkname(name,varargin)">checkname</a>(name,varargin{:}),<span class="string">'&quot;: []'</span>};
0257     <span class="keyword">else</span>
0258         txt={padding0, <span class="string">'[]'</span>};
0259     <span class="keyword">end</span>
0260     txt = sprintf(<span class="string">'%s'</span>,txt{:});
0261     <span class="keyword">return</span>;
0262 <span class="keyword">end</span>
0263 <span class="keyword">if</span>(~isempty(name)) 
0264     <span class="keyword">if</span>(forcearray)
0265         txt={padding0, <span class="string">'&quot;'</span>, <a href="#_sub8" class="code" title="subfunction newname=checkname(name,varargin)">checkname</a>(name,varargin{:}),<span class="string">'&quot;: ['</span>, nl};
0266     <span class="keyword">end</span>
0267 <span class="keyword">else</span>
0268     <span class="keyword">if</span>(forcearray)
0269         txt={padding0, <span class="string">'['</span>, nl};
0270     <span class="keyword">end</span>
0271 <span class="keyword">end</span>
0272 <span class="keyword">for</span> j=1:dim(2)
0273   <span class="keyword">if</span>(dim(1)&gt;1)
0274       txt(end+1:end+3)={padding2,<span class="string">'['</span>,nl};
0275   <span class="keyword">end</span>
0276   <span class="keyword">for</span> i=1:dim(1)
0277     names = fieldnames(item(i,j));
0278     <span class="keyword">if</span>(~isempty(name) &amp;&amp; len==1 &amp;&amp; ~forcearray)
0279         txt(end+1:end+5)={padding1, <span class="string">'&quot;'</span>, <a href="#_sub8" class="code" title="subfunction newname=checkname(name,varargin)">checkname</a>(name,varargin{:}),<span class="string">'&quot;: {'</span>, nl};
0280     <span class="keyword">else</span>
0281         txt(end+1:end+3)={padding1, <span class="string">'{'</span>, nl};
0282     <span class="keyword">end</span>
0283     <span class="keyword">if</span>(~isempty(names))
0284       <span class="keyword">for</span> e=1:length(names)
0285         txt{end+1}=<a href="#_sub1" class="code" title="subfunction txt=obj2json(name,item,level,varargin)">obj2json</a>(names{e},item(i,j).(names{e}),<span class="keyword">...</span>
0286              level+(dim(1)&gt;1)+1+forcearray,varargin{:});
0287         <span class="keyword">if</span>(e&lt;length(names))
0288             txt{end+1}=<span class="string">','</span>;
0289         <span class="keyword">end</span>
0290         txt{end+1}=nl;
0291       <span class="keyword">end</span>
0292     <span class="keyword">end</span>
0293     txt(end+1:end+2)={padding1,<span class="string">'}'</span>};
0294     <span class="keyword">if</span>(i&lt;dim(1))
0295         txt(end+1:end+2)={<span class="string">','</span> nl};
0296     <span class="keyword">end</span>
0297   <span class="keyword">end</span>
0298   <span class="keyword">if</span>(dim(1)&gt;1)
0299       txt(end+1:end+3)={nl,padding2,<span class="string">']'</span>};
0300   <span class="keyword">end</span>
0301   <span class="keyword">if</span>(j&lt;dim(2))
0302       txt(end+1:end+2)={<span class="string">','</span> nl};
0303   <span class="keyword">end</span>
0304 <span class="keyword">end</span>
0305 <span class="keyword">if</span>(forcearray)
0306     txt(end+1:end+3)={nl,padding0,<span class="string">']'</span>};
0307 <span class="keyword">end</span>
0308 txt = sprintf(<span class="string">'%s'</span>,txt{:});
0309 
0310 <span class="comment">%%-------------------------------------------------------------------------</span>
0311 <a name="_sub4" href="#_subfunctions" class="code">function txt=str2json(name,item,level,varargin)</a>
0312 txt={};
0313 <span class="keyword">if</span>(~ischar(item))
0314         error(<span class="string">'input is not a string'</span>);
0315 <span class="keyword">end</span>
0316 item=reshape(item, max(size(item),[1 0]));
0317 len=size(item,1);
0318 ws=struct(<span class="string">'tab'</span>,sprintf(<span class="string">'\t'</span>),<span class="string">'newline'</span>,sprintf(<span class="string">'\n'</span>),<span class="string">'sep'</span>,sprintf(<span class="string">',\n'</span>));
0319 ws=<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'whitespaces_'</span>,ws,varargin{:});
0320 padding1=repmat(ws.tab,1,level);
0321 padding0=repmat(ws.tab,1,level+1);
0322 nl=ws.newline;
0323 sep=ws.sep;
0324 
0325 <span class="keyword">if</span>(~isempty(name)) 
0326     <span class="keyword">if</span>(len&gt;1)
0327         txt={padding1, <span class="string">'&quot;'</span>, <a href="#_sub8" class="code" title="subfunction newname=checkname(name,varargin)">checkname</a>(name,varargin{:}),<span class="string">'&quot;: ['</span>, nl};
0328     <span class="keyword">end</span>
0329 <span class="keyword">else</span>
0330     <span class="keyword">if</span>(len&gt;1)
0331         txt={padding1, <span class="string">'['</span>, nl};
0332     <span class="keyword">end</span>
0333 <span class="keyword">end</span>
0334 <span class="keyword">for</span> e=1:len
0335     val=<a href="#_sub9" class="code" title="subfunction newstr=escapejsonstring(str)">escapejsonstring</a>(item(e,:));
0336     <span class="keyword">if</span>(len==1)
0337         obj=[<span class="string">'&quot;'</span> <a href="#_sub8" class="code" title="subfunction newname=checkname(name,varargin)">checkname</a>(name,varargin{:}) <span class="string">'&quot;: '</span> <span class="string">'&quot;'</span>,val,<span class="string">'&quot;'</span>];
0338         <span class="keyword">if</span>(isempty(name))
0339             obj=[<span class="string">'&quot;'</span>,val,<span class="string">'&quot;'</span>];
0340         <span class="keyword">end</span>
0341         txt(end+1:end+2)={padding1, obj};
0342     <span class="keyword">else</span>
0343         txt(end+1:end+4)={padding0,<span class="string">'&quot;'</span>,val,<span class="string">'&quot;'</span>};
0344     <span class="keyword">end</span>
0345     <span class="keyword">if</span>(e==len)
0346         sep=<span class="string">''</span>;
0347     <span class="keyword">end</span>
0348     txt{end+1}=sep;
0349 <span class="keyword">end</span>
0350 <span class="keyword">if</span>(len&gt;1)
0351     txt(end+1:end+3)={nl,padding1,<span class="string">']'</span>};
0352 <span class="keyword">end</span>
0353 txt = sprintf(<span class="string">'%s'</span>,txt{:});
0354 
0355 <span class="comment">%%-------------------------------------------------------------------------</span>
0356 <a name="_sub5" href="#_subfunctions" class="code">function txt=mat2json(name,item,level,varargin)</a>
0357 <span class="keyword">if</span>(~isnumeric(item) &amp;&amp; ~islogical(item))
0358         error(<span class="string">'input is not an array'</span>);
0359 <span class="keyword">end</span>
0360 ws=struct(<span class="string">'tab'</span>,sprintf(<span class="string">'\t'</span>),<span class="string">'newline'</span>,sprintf(<span class="string">'\n'</span>),<span class="string">'sep'</span>,sprintf(<span class="string">',\n'</span>));
0361 ws=<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'whitespaces_'</span>,ws,varargin{:});
0362 padding1=repmat(ws.tab,1,level);
0363 padding0=repmat(ws.tab,1,level+1);
0364 nl=ws.newline;
0365 sep=ws.sep;
0366 
0367 <span class="keyword">if</span>(length(size(item))&gt;2 || issparse(item) || ~isreal(item) || <span class="keyword">...</span>
0368    (isempty(item) &amp;&amp; any(size(item))) ||<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'ArrayToStruct'</span>,0,varargin{:}))
0369     <span class="keyword">if</span>(isempty(name))
0370         txt=sprintf(<span class="string">'%s{%s%s&quot;_ArrayType_&quot;: &quot;%s&quot;,%s%s&quot;_ArraySize_&quot;: %s,%s'</span>,<span class="keyword">...</span>
0371               padding1,nl,padding0,class(item),nl,padding0,regexprep(mat2str(size(item)),<span class="string">'\s+'</span>,<span class="string">','</span>),nl);
0372     <span class="keyword">else</span>
0373         txt=sprintf(<span class="string">'%s&quot;%s&quot;: {%s%s&quot;_ArrayType_&quot;: &quot;%s&quot;,%s%s&quot;_ArraySize_&quot;: %s,%s'</span>,<span class="keyword">...</span>
0374               padding1,<a href="#_sub8" class="code" title="subfunction newname=checkname(name,varargin)">checkname</a>(name,varargin{:}),nl,padding0,class(item),nl,padding0,regexprep(mat2str(size(item)),<span class="string">'\s+'</span>,<span class="string">','</span>),nl);
0375     <span class="keyword">end</span>
0376 <span class="keyword">else</span>
0377     <span class="keyword">if</span>(numel(item)==1 &amp;&amp; <a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'SingletArray'</span>,0,varargin{:})==0 &amp;&amp; level&gt;0)
0378         numtxt=regexprep(regexprep(<a href="#_sub7" class="code" title="subfunction txt=matdata2json(mat,level,varargin)">matdata2json</a>(item,level+1,varargin{:}),<span class="string">'^\['</span>,<span class="string">''</span>),<span class="string">']'</span>,<span class="string">''</span>);
0379     <span class="keyword">else</span>
0380         numtxt=<a href="#_sub7" class="code" title="subfunction txt=matdata2json(mat,level,varargin)">matdata2json</a>(item,level+1,varargin{:});
0381     <span class="keyword">end</span>
0382     <span class="keyword">if</span>(isempty(name))
0383         txt=sprintf(<span class="string">'%s%s'</span>,padding1,numtxt);
0384     <span class="keyword">else</span>
0385         <span class="keyword">if</span>(numel(item)==1 &amp;&amp; <a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'SingletArray'</span>,0,varargin{:})==0)
0386                txt=sprintf(<span class="string">'%s&quot;%s&quot;: %s'</span>,padding1,<a href="#_sub8" class="code" title="subfunction newname=checkname(name,varargin)">checkname</a>(name,varargin{:}),numtxt);
0387         <span class="keyword">else</span>
0388             txt=sprintf(<span class="string">'%s&quot;%s&quot;: %s'</span>,padding1,<a href="#_sub8" class="code" title="subfunction newname=checkname(name,varargin)">checkname</a>(name,varargin{:}),numtxt);
0389         <span class="keyword">end</span>
0390     <span class="keyword">end</span>
0391     <span class="keyword">return</span>;
0392 <span class="keyword">end</span>
0393 dataformat=<span class="string">'%s%s%s%s%s'</span>;
0394 
0395 <span class="keyword">if</span>(issparse(item))
0396     [ix,iy]=find(item);
0397     data=full(item(find(item)));
0398     <span class="keyword">if</span>(~isreal(item))
0399        data=[real(data(:)),imag(data(:))];
0400        <span class="keyword">if</span>(size(item,1)==1)
0401            <span class="comment">% Kludge to have data's 'transposedness' match item's.</span>
0402            <span class="comment">% (Necessary for complex row vector handling below.)</span>
0403            data=data';
0404        <span class="keyword">end</span>
0405        txt=sprintf(dataformat,txt,padding0,<span class="string">'&quot;_ArrayIsComplex_&quot;: '</span>,<span class="string">'1'</span>, sep);
0406     <span class="keyword">end</span>
0407     txt=sprintf(dataformat,txt,padding0,<span class="string">'&quot;_ArrayIsSparse_&quot;: '</span>,<span class="string">'1'</span>, sep);
0408     <span class="keyword">if</span>(size(item,1)==1)
0409         <span class="comment">% Row vector, store only column indices.</span>
0410         txt=sprintf(dataformat,txt,padding0,<span class="string">'&quot;_ArrayData_&quot;: '</span>,<span class="keyword">...</span>
0411            <a href="#_sub7" class="code" title="subfunction txt=matdata2json(mat,level,varargin)">matdata2json</a>([iy(:),data'],level+2,varargin{:}), nl);
0412     <span class="keyword">elseif</span>(size(item,2)==1)
0413         <span class="comment">% Column vector, store only row indices.</span>
0414         txt=sprintf(dataformat,txt,padding0,<span class="string">'&quot;_ArrayData_&quot;: '</span>,<span class="keyword">...</span>
0415            <a href="#_sub7" class="code" title="subfunction txt=matdata2json(mat,level,varargin)">matdata2json</a>([ix,data],level+2,varargin{:}), nl);
0416     <span class="keyword">else</span>
0417         <span class="comment">% General case, store row and column indices.</span>
0418         txt=sprintf(dataformat,txt,padding0,<span class="string">'&quot;_ArrayData_&quot;: '</span>,<span class="keyword">...</span>
0419            <a href="#_sub7" class="code" title="subfunction txt=matdata2json(mat,level,varargin)">matdata2json</a>([ix,iy,data],level+2,varargin{:}), nl);
0420     <span class="keyword">end</span>
0421 <span class="keyword">else</span>
0422     <span class="keyword">if</span>(isreal(item))
0423         txt=sprintf(dataformat,txt,padding0,<span class="string">'&quot;_ArrayData_&quot;: '</span>,<span class="keyword">...</span>
0424             <a href="#_sub7" class="code" title="subfunction txt=matdata2json(mat,level,varargin)">matdata2json</a>(item(:)',level+2,varargin{:}), nl);
0425     <span class="keyword">else</span>
0426         txt=sprintf(dataformat,txt,padding0,<span class="string">'&quot;_ArrayIsComplex_&quot;: '</span>,<span class="string">'1'</span>, sep);
0427         txt=sprintf(dataformat,txt,padding0,<span class="string">'&quot;_ArrayData_&quot;: '</span>,<span class="keyword">...</span>
0428             <a href="#_sub7" class="code" title="subfunction txt=matdata2json(mat,level,varargin)">matdata2json</a>([real(item(:)) imag(item(:))],level+2,varargin{:}), nl);
0429     <span class="keyword">end</span>
0430 <span class="keyword">end</span>
0431 txt=sprintf(<span class="string">'%s%s%s'</span>,txt,padding1,<span class="string">'}'</span>);
0432 
0433 <span class="comment">%%-------------------------------------------------------------------------</span>
0434 <a name="_sub6" href="#_subfunctions" class="code">function txt=matlabobject2json(name,item,level,varargin)</a>
0435 <span class="keyword">if</span> numel(item) == 0 <span class="comment">%empty object</span>
0436     st = struct();
0437 <span class="keyword">else</span>
0438     <span class="comment">% &quot;st = struct(item);&quot; would produce an inmutable warning, because it</span>
0439     <span class="comment">% make the protected and private properties visible. Instead we get the</span>
0440     <span class="comment">% visible properties</span>
0441     propertynames = properties(item);
0442     <span class="keyword">for</span> p = 1:numel(propertynames)
0443         <span class="keyword">for</span> o = numel(item):-1:1 <span class="comment">% aray of objects</span>
0444             st(o).(propertynames{p}) = item(o).(propertynames{p});
0445         <span class="keyword">end</span>
0446     <span class="keyword">end</span>
0447 <span class="keyword">end</span>
0448 txt=<a href="#_sub3" class="code" title="subfunction txt=struct2json(name,item,level,varargin)">struct2json</a>(name,st,level,varargin{:});
0449 
0450 <span class="comment">%%-------------------------------------------------------------------------</span>
0451 <a name="_sub7" href="#_subfunctions" class="code">function txt=matdata2json(mat,level,varargin)</a>
0452 
0453 ws=struct(<span class="string">'tab'</span>,sprintf(<span class="string">'\t'</span>),<span class="string">'newline'</span>,sprintf(<span class="string">'\n'</span>),<span class="string">'sep'</span>,sprintf(<span class="string">',\n'</span>));
0454 ws=<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'whitespaces_'</span>,ws,varargin{:});
0455 tab=ws.tab;
0456 nl=ws.newline;
0457 
0458 <span class="keyword">if</span>(size(mat,1)==1)
0459     pre=<span class="string">''</span>;
0460     post=<span class="string">''</span>;
0461     level=level-1;
0462 <span class="keyword">else</span>
0463     pre=sprintf(<span class="string">'[%s'</span>,nl);
0464     post=sprintf(<span class="string">'%s%s]'</span>,nl,repmat(tab,1,level-1));
0465 <span class="keyword">end</span>
0466 
0467 <span class="keyword">if</span>(isempty(mat))
0468     txt=<span class="string">'null'</span>;
0469     <span class="keyword">return</span>;
0470 <span class="keyword">end</span>
0471 floatformat=<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'FloatFormat'</span>,<span class="string">'%.10g'</span>,varargin{:});
0472 <span class="comment">%if(numel(mat)&gt;1)</span>
0473     formatstr=[<span class="string">'['</span> repmat([floatformat <span class="string">','</span>],1,size(mat,2)-1) [floatformat sprintf(<span class="string">'],%s'</span>,nl)]];
0474 <span class="comment">%else</span>
0475 <span class="comment">%    formatstr=[repmat([floatformat ','],1,size(mat,2)-1) [floatformat sprintf(',\n')]];</span>
0476 <span class="comment">%end</span>
0477 
0478 <span class="keyword">if</span>(nargin&gt;=2 &amp;&amp; size(mat,1)&gt;1 &amp;&amp; <a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'ArrayIndent'</span>,1,varargin{:})==1)
0479     formatstr=[repmat(tab,1,level) formatstr];
0480 <span class="keyword">end</span>
0481 
0482 txt=sprintf(formatstr,mat');
0483 txt(end-length(nl):end)=[];
0484 <span class="keyword">if</span>(islogical(mat) &amp;&amp; <a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'ParseLogical'</span>,0,varargin{:})==1)
0485    txt=regexprep(txt,<span class="string">'1'</span>,<span class="string">'true'</span>);
0486    txt=regexprep(txt,<span class="string">'0'</span>,<span class="string">'false'</span>);
0487 <span class="keyword">end</span>
0488 <span class="comment">%txt=regexprep(mat2str(mat),'\s+',',');</span>
0489 <span class="comment">%txt=regexprep(txt,';',sprintf('],\n['));</span>
0490 <span class="comment">% if(nargin&gt;=2 &amp;&amp; size(mat,1)&gt;1)</span>
0491 <span class="comment">%     txt=regexprep(txt,'\[',[repmat(sprintf('\t'),1,level) '[']);</span>
0492 <span class="comment">% end</span>
0493 txt=[pre txt post];
0494 <span class="keyword">if</span>(any(isinf(mat(:))))
0495     txt=regexprep(txt,<span class="string">'([-+]*)Inf'</span>,<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'Inf'</span>,<span class="string">'&quot;$1_Inf_&quot;'</span>,varargin{:}));
0496 <span class="keyword">end</span>
0497 <span class="keyword">if</span>(any(isnan(mat(:))))
0498     txt=regexprep(txt,<span class="string">'NaN'</span>,<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'NaN'</span>,<span class="string">'&quot;_NaN_&quot;'</span>,varargin{:}));
0499 <span class="keyword">end</span>
0500 
0501 <span class="comment">%%-------------------------------------------------------------------------</span>
0502 <a name="_sub8" href="#_subfunctions" class="code">function newname=checkname(name,varargin)</a>
0503 isunpack=<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'UnpackHex'</span>,1,varargin{:});
0504 newname=name;
0505 <span class="keyword">if</span>(isempty(regexp(name,<span class="string">'0x([0-9a-fA-F]+)_'</span>,<span class="string">'once'</span>)))
0506     <span class="keyword">return</span>
0507 <span class="keyword">end</span>
0508 <span class="keyword">if</span>(isunpack)
0509     isoct=<a href="jsonopt.html" class="code" title="function val=jsonopt(key,default,varargin)">jsonopt</a>(<span class="string">'IsOctave'</span>,0,varargin{:});
0510     <span class="keyword">if</span>(~isoct)
0511         newname=regexprep(name,<span class="string">'(^x|_){1}0x([0-9a-fA-F]+)_'</span>,<span class="string">'${native2unicode(hex2dec($2))}'</span>);
0512     <span class="keyword">else</span>
0513         pos=regexp(name,<span class="string">'(^x|_){1}0x([0-9a-fA-F]+)_'</span>,<span class="string">'start'</span>);
0514         pend=regexp(name,<span class="string">'(^x|_){1}0x([0-9a-fA-F]+)_'</span>,<span class="string">'end'</span>);
0515         <span class="keyword">if</span>(isempty(pos))
0516             <span class="keyword">return</span>;
0517         <span class="keyword">end</span>
0518         str0=name;
0519         pos0=[0 pend(:)' length(name)];
0520         newname=<span class="string">''</span>;
0521         <span class="keyword">for</span> i=1:length(pos)
0522             newname=[newname str0(pos0(i)+1:pos(i)-1) char(hex2dec(str0(pos(i)+3:pend(i)-1)))];
0523         <span class="keyword">end</span>
0524         <span class="keyword">if</span>(pos(end)~=length(name))
0525             newname=[newname str0(pos0(end-1)+1:pos0(end))];
0526         <span class="keyword">end</span>
0527     <span class="keyword">end</span>
0528 <span class="keyword">end</span>
0529 
0530 <span class="comment">%%-------------------------------------------------------------------------</span>
0531 <a name="_sub9" href="#_subfunctions" class="code">function newstr=escapejsonstring(str)</a>
0532 newstr=str;
0533 isoct=exist(<span class="string">'OCTAVE_VERSION'</span>,<span class="string">'builtin'</span>);
0534 <span class="keyword">if</span>(isoct)
0535    vv=sscanf(OCTAVE_VERSION,<span class="string">'%f'</span>);
0536    <span class="keyword">if</span>(vv(1)&gt;=3.8)
0537        isoct=0;
0538    <span class="keyword">end</span>
0539 <span class="keyword">end</span>
0540 <span class="keyword">if</span>(isoct)
0541   escapechars={<span class="string">'\\'</span>,<span class="string">'\&quot;'</span>,<span class="string">'\/'</span>,<span class="string">'\a'</span>,<span class="string">'\f'</span>,<span class="string">'\n'</span>,<span class="string">'\r'</span>,<span class="string">'\t'</span>,<span class="string">'\v'</span>};
0542   <span class="keyword">for</span> i=1:length(escapechars);
0543     newstr=regexprep(newstr,escapechars{i},escapechars{i});
0544   <span class="keyword">end</span>
0545   newstr=regexprep(newstr,<span class="string">'\\\\(u[0-9a-fA-F]{4}[^0-9a-fA-F]*)'</span>,<span class="string">'\$1'</span>);
0546 <span class="keyword">else</span>
0547   escapechars={<span class="string">'\\'</span>,<span class="string">'\&quot;'</span>,<span class="string">'\/'</span>,<span class="string">'\a'</span>,<span class="string">'\b'</span>,<span class="string">'\f'</span>,<span class="string">'\n'</span>,<span class="string">'\r'</span>,<span class="string">'\t'</span>,<span class="string">'\v'</span>};
0548   <span class="keyword">for</span> i=1:length(escapechars);
0549     newstr=regexprep(newstr,escapechars{i},regexprep(escapechars{i},<span class="string">'\\'</span>,<span class="string">'\\\\'</span>));
0550   <span class="keyword">end</span>
0551   newstr=regexprep(newstr,<span class="string">'\\\\(u[0-9a-fA-F]{4}[^0-9a-fA-F]*)'</span>,<span class="string">'\\$1'</span>);
0552 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 17-Nov-2017 17:25:01 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>